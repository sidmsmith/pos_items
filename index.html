<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Item Generator v0.5.27</title>
  <!-- Trigger Vercel deployment sync - v0.5.27 Feature: auto-scroll gallery row to selected image page when returning from preview modal -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-TdLkn9X3yYbplwVpO6ghPEP3syyLBb4Z8RXOqfN4KVm3vIPpcPpC5XJK0A0VYHkH3VddOZXS6SmfDk5F7bP2Nw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      --bg-dark: #121212;
      --card-bg: #1e1e1e;
      --input-bg: #2d2d2d;
      --border: #333;
      --text: #e0e0e0;
      --red-text: #ff6b6b;
      --blue-select: #339af0;
      --success: #28a745;
      --primary: #0d6efd;
      --orange: #e67700;
      --purple: #9c27b0;
    }

    body { 
      background: var(--bg-dark); 
      color: var(--text); 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      min-height: 100vh;
      margin: 0;
      padding-bottom: 2rem;
    }

    .main-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      padding: 1.5rem;
      margin: 1rem;
      display: flex;
      flex-direction: column;
    }

    @media (min-width: 769px) {
      .main-card { max-width: 1200px; margin: 2rem auto; }
    }

    .form-control, .form-select, textarea {
      background: var(--input-bg);
      border: 1px solid #444;
      color: #fff;
      border-radius: 8px;
    }
    .form-control:focus, .form-select:focus, textarea:focus {
      background: #333;
      border-color: var(--primary);
      box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);
      color: #fff;
    }

    .btn-primary { background: var(--primary); border: none; }
    .btn-success { background: var(--success); border: none; }
    .btn-secondary { background: #6c757d; border: none; }
    .btn-danger { background: #dc3545; border: none; color: white; }
    .btn-orange { background: var(--orange); border: none; color: white; }
    .btn-blue { background: #1e90ff; border: none; }
    .btn-purple { background: var(--purple); border: none; }
    .btn-primary:hover { background: #0b5ed7; }
    .btn-success:hover { background: #218838; }
    .btn-danger:hover { background: #c82333; }
    .btn-orange:hover { background: #c65f00; }
    .btn-blue:hover { background: #1c7ed6; }
    .btn-purple:hover { background: #7b1fa2; }

    .section-frame {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
      background: var(--card-bg);
    }

    .section-title {
      font-size: 16px;
      font-weight: bold;
      color: var(--primary);
      margin-bottom: 0.5rem;
    }

    .form-label { color: #bbbbbb; font-weight: 600; font-size: 0.9em; }
    small { color: #999; font-size: 0.85em; }
    h2 { color: var(--primary); text-align: center; margin-bottom: 1.5rem; }
    
    /* Gallery View Styles */
    .gallery-item {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem;
      border-radius: 8px;
      background: var(--input-bg);
      border: 2px solid transparent;
      transition: all 0.3s ease;
      cursor: pointer;
      width: 100%;
      min-width: 0;
      overflow: hidden;
    }
    
    .gallery-item.selected {
      border-color: #00ffff;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.6), 0 0 30px rgba(0, 255, 255, 0.4);
    }
    
    .gallery-item:hover {
      background: #333;
      transform: translateY(-2px);
    }
    
    .gallery-thumbnail {
      width: 100%;
      height: 150px;
      min-height: 150px;
      object-fit: cover;
      border-radius: 4px;
      background: var(--card-bg);
      border: 1px solid var(--border);
      display: block;
    }
    
    .gallery-thumbnail.loading {
      opacity: 0.5;
      background: var(--input-bg);
    }
    
    .gallery-info {
      margin-top: 0.5rem;
      text-align: center;
      width: 100%;
    }
    
    .gallery-filename {
      font-size: 0.75em;
      color: var(--text);
      word-break: break-word;
      font-weight: 500;
    }
    
    .gallery-subfolder {
      font-size: 0.65em;
      color: #999;
      margin-top: 0.25rem;
      font-style: italic;
    }

    .progress { height: 12px; background: var(--input-bg); border-radius: 6px; }
    .progress-bar { background: var(--success); }

    .status-label {
      font-size: 0.85em;
      color: #999;
      margin-top: 0.25rem;
    }

    /* Console Output */
    .console-output {
      background: #000;
      border: 1px solid #444;
      border-radius: 8px;
      color: #0f0;
      font-family: 'Courier New', monospace;
      font-size: 0.8em;
      padding: 0.75rem;
      height: 300px;
      overflow-y: auto;
      margin-top: 1rem;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .console-output .error { color: #ff6b6b; }
    .console-output .success { color: #51cf66; }
    .console-output .info { color: #339af0; }
    .console-output .warning { color: #ffd43b; }

    .input-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .input-row label {
      min-width: 150px;
      margin-bottom: 0;
    }

    .input-row input, .input-row select {
      flex: 1;
    }

    .btn-row {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    .products-display {
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      max-height: 300px;
      overflow-y: auto;
      margin-top: 0.5rem;
    }

    .product-item {
      padding: 0.25rem 0;
      color: var(--text);
    }

    /* Modal/Popup Styles */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal-content {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 2rem;
      max-width: 700px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }

    .modal-header {
      font-size: 1.3rem;
      font-weight: bold;
      color: var(--primary);
      margin-bottom: 1rem;
    }

    .script-display {
      background: #000;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 1rem;
      font-family: 'Courier New', monospace;
      font-size: 0.85em;
      color: #0f0;
      max-height: 300px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
      margin-bottom: 1rem;
    }

    .script-display.truncated::after {
      content: '\n\n... (script continues - use Copy Script to get full version)';
      color: #999;
    }

    .modal-buttons {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    .modal-buttons .btn {
      min-width: 140px;
    }

    /* Gallery Styles */
    .gallery-modal {
      max-width: 1320px;
      width: 95%;
      max-height: 95vh;
    }

    .gallery-header {
      border-bottom: 1px solid #222638;
      padding-bottom: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .gallery-title {
      font-size: 1.4rem;
      font-weight: 600;
      color: #fff;
    }

    .gallery-subtitle {
      color: #adb5ff;
      font-size: 0.9rem;
      margin-top: 0.25rem;
    }

    .gallery-instruction {
      color: #ff6b6b;
      font-size: 0.9rem;
      min-height: 1.2rem;
      margin-bottom: 0.25rem;
    }

    .gallery-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }

    .gallery-toolbar-left,
    .gallery-toolbar-right {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .gallery-grid {
      display: flex;
      flex-direction: column;
      gap: 0.35rem; /* Further reduced gap to fit 2 rows without scrollbar */
      max-height: calc(100vh - 320px); /* Adjusted to fit 2 rows without scrollbar */
      overflow-y: auto;
      padding-right: 0.5rem;
    }

    .variant-row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .gallery-group {
      border: 1px solid #1f2233;
      border-radius: 12px;
      padding: 0.4rem 0.6rem 0.4rem; /* Reduced padding to save vertical space */
      background: #111321;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      margin-bottom: 0; /* Remove margin-bottom, gap handles spacing */
    }

    .gallery-group-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.35rem; /* Reduced margin to save space */
    }

    .gallery-group-header h5 {
      margin: 0;
      font-size: 1rem;
      color: #fff;
      margin-right: auto;
    }

    .gallery-controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-left: auto;
    }

    .skip-checkbox {
      width: 20px;
      height: 20px;
      cursor: pointer;
      accent-color: #ff6b6b;
      filter: hue-rotate(0deg) saturate(1.2);
      appearance: none;
      -webkit-appearance: none;
      border: 2px solid #ff6b6b;
      border-radius: 3px;
      background-color: transparent;
      position: relative;
    }
    
    .skip-checkbox:checked {
      background-color: #ff6b6b;
    }
    
    .skip-checkbox:checked::after {
      content: '‚úì';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 14px;
      font-weight: bold;
    }

    .refresh-btn {
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      padding: 0.4rem 0.6rem;
      cursor: pointer;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: 0.3rem;
      transition: all 0.2s ease;
    }

    .refresh-btn:hover {
      background: #333;
      border-color: var(--primary);
    }

    .refresh-btn:active {
      transform: scale(0.95);
    }

    .refresh-btn.loading {
      opacity: 0.6;
      cursor: not-allowed;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .gallery-group.skipped {
      opacity: 0.5;
      background: rgba(255, 107, 107, 0.1);
      border-color: rgba(255, 107, 107, 0.5);
    }

    .gallery-group.skipped .gallery-group-header h5 {
      text-decoration: line-through;
      color: #999;
    }

    .new-images-badge {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: var(--success);
      color: white;
      font-size: 0.7rem;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-weight: bold;
      z-index: 5;
    }

    .gallery-card.new-image {
      position: relative;
    }

    .gallery-item-id {
      color: #9aa4d3;
      font-size: 0.8rem;
      display: inline-block;
      margin-top: 0.15rem;
    }

    .gallery-card {
      background: #080b14;
      border: 1px solid #242b44;
      border-radius: 12px;
      padding: 0.5rem; /* Reduced padding to ensure halo visibility */
      width: 200px; /* Slightly reduced to ensure full halo visibility with margin */
      min-width: 200px;
      max-width: 200px;
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      gap: 0.35rem; /* Reduced gap between card elements */
      cursor: pointer;
      transition: border 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
      margin: 3px; /* Add margin to ensure halo is fully visible */
    }

    .gallery-card-image {
      border-radius: 10px;
      overflow: hidden;
      background: #000;
      height: 110px; /* Reduced to fit better with smaller card */
    }

    .gallery-card-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .gallery-card-body {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.8rem; /* Slightly reduced font size */
    }

    .gallery-card-title {
      font-weight: 600;
      color: #fff;
      white-space: nowrap; /* Force Variant X to stay on one line */
      overflow: hidden;
      text-overflow: ellipsis; /* Show ellipsis if text is too long */
    }

    .gallery-card-source {
      color: #9aa4d3;
      font-size: 0.7rem; /* Slightly reduced font size */
      text-align: right;
      word-break: break-word; /* Allow URL text to wrap multiple lines */
    }

    .gallery-preview-btn {
      border: 1px solid #3f4b6b;
      border-radius: 999px;
      padding: 0.2rem 0.8rem;
      font-size: 0.75rem;
      background: transparent;
      color: #fff;
      align-self: flex-start;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .gallery-preview-btn:hover {
      background: #3f4b6b;
    }

    .gallery-card.selected {
      border-color: #2f9e44;
      box-shadow: 0 0 0 3px rgba(47, 158, 68, 0.5); /* Increased halo visibility */
      transform: translateY(-2px);
      margin: 3px; /* Ensure margin is maintained when selected */
    }

    .variant-slider {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .slider-viewport {
      overflow: hidden;
      flex: 1;
    }

    .slider-track {
      display: flex;
      gap: 0.5rem; /* Reduced gap between cards in slider */
      transition: transform 0.3s ease;
      width: max-content; /* Ensure track is wide enough for all cards */
    }

    .slider-nav-btn {
      background: transparent;
      border: 1px solid #3f4b6b;
      color: #fff;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1rem;
    }

    .variant-slider.no-nav .slider-nav-btn {
      visibility: hidden;
    }

    .gallery-warning {
      background: rgba(230, 119, 0, 0.15);
      border: 1px solid var(--orange);
      border-radius: 8px;
      padding: 0.75rem;
      color: #ffc078;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .hidden-warning {
      display: none;
    }

    .gallery-empty {
      font-size: 0.85rem;
      color: #bbb;
      border: 1px dashed #444;
      border-radius: 8px;
      padding: 0.5rem;
      text-align: center;
    }

    .gallery-footer-status {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      color: #bbb;
      min-height: 1.2em;
    }

    .carousel-modal {
      max-width: 900px;
      width: 95%;
      max-height: 90vh; /* Increased from default to accommodate content below image */
    }

    .carousel-body {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem; /* Add space between image and caption */
    }

    .carousel-image {
      flex: 1;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
      height: 500px; /* Increased from 420px to give more space */
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .carousel-image img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .carousel-nav-btn {
      background: transparent;
      border: 1px solid #3f4b6b;
      color: #fff;
      border-radius: 50%;
      width: 42px;
      height: 42px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.1rem;
    }

    .carousel-caption {
      background: #1a1d2e; /* Grey background section */
      border-radius: 8px;
      padding: 1rem 1.25rem; /* Generous padding */
      margin-top: 1rem; /* Space above the grey section */
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
      color: #fff; /* Ensure text is visible */
      border: 1px solid #242b44; /* Subtle border */
    }

    .carousel-caption a {
      color: #66d9ff;
      text-decoration: underline;
      font-size: 0.85rem;
    }
  </style>
</head>
<body>
  <!-- PowerShell Script Modal -->
  <div class="modal-overlay" id="scriptModal">
    <div class="modal-content">
      <div class="modal-header">PowerShell Script to Move Files</div>
      <div class="script-display" id="scriptDisplay"></div>
      <div class="modal-buttons">
        <button class="btn btn-success" onclick="downloadScript()">Download Script</button>
        <button class="btn btn-primary" onclick="copyScript(event)">Copy Script</button>
        <button class="btn btn-secondary" onclick="closeScriptModal()">Close</button>
      </div>
    </div>
  </div>
  <!-- Gallery Modal -->
  <div class="modal-overlay" id="galleryModal">
    <div class="modal-content gallery-modal">
      <div class="modal-header gallery-header">
        <div>
          <div class="gallery-title">Review Images</div>
          <div class="gallery-subtitle" id="gallerySelectionSummary">0 of 0 items selected</div>
        </div>
      </div>
      <div class="gallery-instruction" id="galleryInstructionMessage"></div>
      <div class="gallery-toolbar">
        <div class="gallery-toolbar-left">
          <button id="gallerySelectFirstBtn" class="btn btn-outline-light btn-sm">Select First Image</button>
          <button id="galleryRefreshBtn" class="btn btn-outline-light btn-sm">Refresh Gallery</button>
        </div>
      <div class="gallery-toolbar-right">
        <button id="galleryCloseBtn" class="btn btn-danger btn-sm">Cancel</button>
        </div>
      </div>
      <div id="galleryWarnings"></div>
      <div class="gallery-grid" id="galleryGrid"></div>
      <div class="gallery-footer-status" id="galleryFooterStatus"></div>
      <div class="gallery-footer-actions" style="display: flex; justify-content: flex-end; align-items: center; gap: 0.5rem; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border); flex-wrap: wrap;">
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <input type="checkbox" id="uploadAfterDownloadGallery" style="margin: 0; cursor: pointer;">
          <label for="uploadAfterDownloadGallery" style="margin: 0; cursor: pointer; color: var(--text); font-size: 0.9em;">Upload to Cloudinary after download</label>
        </div>
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <input type="checkbox" id="updateWmAfterDownloadGallery" style="margin: 0; cursor: pointer;">
          <label for="updateWmAfterDownloadGallery" style="margin: 0; cursor: pointer; color: var(--text); font-size: 0.9em;">Update WM after download</label>
        </div>
        <button id="gallerySaveBtn" class="btn btn-success btn-sm" disabled title="">Download Selected Items</button>
      </div>
    </div>
  </div>
  <!-- Variant Carousel Modal -->
  <div class="modal-overlay" id="carouselModal">
    <div class="modal-content carousel-modal">
      <div class="modal-header d-flex justify-content-between align-items-center">
        <span id="carouselTitle"></span>
        <button class="btn btn-outline-secondary btn-sm" id="carouselCloseBtn">Close</button>
      </div>
      <div class="carousel-body">
        <button class="carousel-nav-btn" id="carouselPrevBtn" type="button">&#8249;</button>
        <div class="carousel-image">
          <img id="carouselImage" src="" alt="Variant preview">
        </div>
        <button class="carousel-nav-btn" id="carouselNextBtn" type="button">&#8250;</button>
      </div>
      <div class="carousel-caption">
        <div id="carouselVariantLabel"></div>
        <div style="display:flex;align-items:center;gap:0.5rem;flex-wrap:wrap;">
          <a id="carouselOpenOriginal" href="#" target="_blank" rel="noopener noreferrer">Open original</a>
          <button class="btn btn-success btn-sm" id="carouselUseBtn" type="button">Use This Image</button>
        </div>
      </div>
    </div>
  </div>
  <div class="main-card">
    <h2>Item Generator v0.5.27</h2>

    <!-- ============================================================================= -->
    <!-- SECTION 1: GENERATE ITEMS -->
    <!-- ============================================================================= -->
    <div class="section-frame">
      <div class="section-title">Generate Items</div>
      
      <div class="input-row">
        <label class="form-label">Company:</label>
        <input type="text" id="company" class="form-control" placeholder="Nike" />
      </div>

      <div class="input-row">
        <label class="form-label">Website (Optional):</label>
        <input type="text" id="website" class="form-control" placeholder="nike.com" />
      </div>

      <div class="input-row">
        <label class="form-label">Item Count:</label>
        <input type="number" id="count" class="form-control" placeholder="30" min="1" />
      </div>

      <div class="input-row">
        <label class="form-label">Extra Prompt:</label>
        <input type="text" id="extra_prompt" class="form-control" placeholder="Optional additional instructions" />
      </div>

      <div class="input-row">
        <label class="form-label">Existing Item List:</label>
        <div style="flex:1; position: relative;">
        <input type="file" id="items_file" class="form-control" accept=".txt" style="display:none;" />
          <input type="text" id="existing_list" class="form-control" placeholder="Load or enter a .txt item list path" style="flex:1; padding-right: 200px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; background-color: rgba(255, 0, 0, 0.1); border-color: rgba(255, 0, 0, 0.3);" />
          <span id="existingListStatus" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); color: var(--success); font-size: 0.85em; pointer-events: none; white-space: nowrap;"></span>
        </div>
        <button class="btn btn-secondary btn-sm" id="existingListLoadBtn" type="button">Load</button>
      </div>

      <div class="input-row">
        <label class="form-label">Reference Items File:</label>
        <div style="flex:1; position: relative;">
          <input type="file" id="item_numbers_csv" class="form-control" accept=".csv,.xls,.xlsx" style="display:none;" />
          <input type="text" id="reference_items_display" class="form-control" placeholder="Load or enter a CSV/Excel file path" style="padding-right: 200px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; background-color: rgba(255, 0, 0, 0.1); border-color: rgba(255, 0, 0, 0.3);" readonly />
          <span id="itemNumbersStatus" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); color: var(--success); font-size: 0.85em; pointer-events: none; white-space: nowrap;"></span>
      </div>
        <button class="btn btn-secondary btn-sm" id="referenceItemsLoadBtn" type="button" title="CSV/Excel file with item numbers (one per row, first column)">Load</button>
      </div>

      <div class="input-row">
        <label class="form-label">Images Per Item:</label>
        <input type="number" id="images_per_item" class="form-control" placeholder="3" min="1" />
      </div>

      <div class="input-row">
        <label class="form-label">Preferred Sites:</label>
        <input type="text" id="sites" class="form-control" placeholder="nike.com, amazon.com" />
      </div>

      <div class="input-row">
        <label class="form-label">Image Filters:</label>
        <input type="text" id="image_filters" class="form-control" placeholder="large, photo, png" />
        <small>Options: large, photo, png, red, etc.</small>
      </div>

      <div class="btn-row">
        <button id="genBtn" class="btn btn-success" style="width: 200px;">Generate Items</button>
      </div>

      <div class="progress mt-2" id="genProgress" style="display: none;">
        <div class="progress-bar" role="progressbar" style="width: 0%"></div>
      </div>
      <div class="status-label" id="genStatus"></div>

    </div>

    <div class="section-frame" id="itemListPanel">
      <div class="section-title d-flex justify-content-between align-items-center">
        <span>Current Item List</span>
        <button id="itemListToggleBtn" class="btn btn-outline-light btn-sm">Hide</button>
      </div>
      <div id="itemListBody">
        <textarea id="itemListTextarea" class="form-control" rows="8" style="background:#0d1117;color:#fff;border:1px solid #333;"></textarea>
        <div id="unappliedChangesBadge" style="display: none; margin-top: 0.5rem; padding: 0.25rem 0.5rem; background: rgba(255, 165, 0, 0.2); border: 1px solid #ffa500; border-radius: 4px; color: #ffa500; font-size: 0.85em;">
          <i class="fas fa-exclamation-triangle" style="margin-right: 0.25rem;"></i>
          <span id="unappliedChangesCount">0</span> unvalidated change(s) - Click "Validate List" or they will be auto-validated on Download
        </div>
      <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem;">
        <div style="display: flex; flex-direction: column; gap: 0.5rem;">
          <div style="display: flex; align-items: center; gap: 0.5rem;">
            <input type="checkbox" id="uploadAfterDownload" style="margin: 0; cursor: pointer;">
            <label for="uploadAfterDownload" style="margin: 0; cursor: pointer; color: var(--text); font-size: 0.9em;">Upload to Cloudinary after download</label>
          </div>
          <div style="display: flex; align-items: center; gap: 0.5rem;">
            <input type="checkbox" id="updateWmAfterDownload" style="margin: 0; cursor: pointer;">
            <label for="updateWmAfterDownload" style="margin: 0; cursor: pointer; color: var(--text); font-size: 0.9em;">Update WM after download</label>
          </div>
        </div>
        <div style="display: flex; justify-content: center; flex: 1;">
          <button id="dlBtn" class="btn btn-success" style="width: 200px;">Download Items</button>
        </div>
        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
          <button id="itemListApplyBtn" class="btn btn-primary btn-sm">Validate List</button>
          <button id="itemListSaveBtn" class="btn btn-outline-light btn-sm">Save List</button>
          <button id="itemListClearBtn" class="btn btn-outline-danger btn-sm">Clear</button>
        </div>
      </div>
      <div class="status-label" id="itemListStatus"></div>
      <div class="progress mt-2" id="dlProgress" style="display: none;">
        <div class="progress-bar" role="progressbar" style="width: 0%"></div>
      </div>
      <div class="status-label" id="dlStatus"></div>
    </div>
  </div>

    <!-- ============================================================================= -->
    <!-- SECTION 2: WORKFLOW -->
    <!-- ============================================================================= -->
    <div class="section-frame">
      <div class="section-title">Additional Parameters</div>

      <div class="input-row">
        <label class="form-label">Update Item CSV File:</label>
        <div style="flex:1; position: relative;">
          <input type="file" id="csv_out_file" class="form-control" accept=".csv,.xls,.xlsx" style="display:none;" />
          <input type="text" id="csv_out" class="form-control" placeholder="Load or enter a CSV/Excel file path" style="flex:1; padding-right: 200px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; background-color: rgba(255, 0, 0, 0.1); border-color: rgba(255, 0, 0, 0.3);" readonly />
          <span id="csvOutStatus" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); color: var(--success); font-size: 0.85em; pointer-events: none; white-space: nowrap;"></span>
        </div>
        <button class="btn btn-secondary btn-sm" id="csvOutLoadBtn" type="button">Load</button>
      </div>

      <div class="input-row">
        <label class="form-label">Cloudinary Prefix:</label>
        <input type="text" id="prefix" class="form-control" placeholder="https://res.cloudinary.com/..." />
      </div>

      <div class="input-row">
        <label class="form-label">Cloudinary Folder:</label>
        <input type="text" id="upload_folder" class="form-control" placeholder="sidney" />
      </div>

      <div class="input-row">
        <label class="form-label">Upload Preset:</label>
        <input type="text" id="upload_profile" class="form-control" placeholder="Optional preset name" />
      </div>

      <div class="input-row">
        <label class="form-label">Image Directory:</label>
        <input type="file" id="save_dir_file" class="form-control" webkitdirectory directory style="display: none;" />
        <input type="text" id="save_dir" class="form-control" placeholder="Select directory for cleanup/upload reference" style="flex: 1;" />
        <button id="chooseDirBtn" class="btn btn-secondary btn-sm" type="button">Choose Directory</button>
        <div style="display: flex; align-items: center; gap: 0.5rem; margin-left: 0.5rem;">
          <input type="checkbox" id="include_subfolders" style="margin: 0;" />
          <label for="include_subfolders" style="margin: 0; font-size: 0.9em; color: var(--text);">Include subfolders</label>
        </div>
      </div>

      <!-- Image Preview Section -->
      <div id="imagePreviewContainer" style="display: none; margin-top: 0.5rem; margin-left: 1rem; padding: 0.75rem; background: var(--input-bg); border: 2px solid var(--primary); border-radius: 6px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
          <div style="font-size: 0.95em; color: var(--text); font-weight: bold;">
            <span style="color: var(--primary);">üìÅ Images:</span> <span id="imageCount" style="color: var(--success);">0</span> file(s) | 
            <span style="color: var(--primary); margin-left: 0.5rem;">Selected:</span> <span id="selectedCount" style="color: var(--success);">0</span>
          </div>
          <div style="display: flex; gap: 0.5rem;">
            <button id="selectAllImages" class="btn btn-secondary btn-sm" type="button" style="font-size: 0.8em; padding: 0.25rem 0.5rem;">Select All</button>
            <button id="deselectAllImages" class="btn btn-secondary btn-sm" type="button" style="font-size: 0.8em; padding: 0.25rem 0.5rem;">Deselect All</button>
          </div>
        </div>
        <div id="imagePreviewList" style="max-height: 400px; overflow-y: auto; background: var(--input-bg); border: 1px solid var(--border); border-radius: 4px; padding: 0.75rem; display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 1rem;">
          <!-- Image gallery will be populated here -->
        </div>
        <div id="imagePreviewNote" style="font-size: 0.8em; color: #999; margin-top: 0.5rem; font-style: italic;">
          Note: The browser may show "Upload 30 files" in the native dialog - this is normal. After confirming, the preview above shows the filtered count based on your "Include subfolders" setting. Click images to toggle selection (selected images have a cyan halo).
        </div>
      </div>

      <div class="btn-row">
        <button id="cleanupBtn" class="btn btn-orange" style="width: 160px; display: none;">Clean Up CSV</button>
        <button id="upBtn" type="button" class="btn btn-blue" style="width: 160px;">Upload to Cloudinary</button>
        <button id="wmBtn" class="btn btn-purple" style="width: 160px;">Update WM</button>
      </div>
      
      <!-- Upload Progress Bar -->
      <div id="uploadProgressContainer" style="display: none; margin-top: 1rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
          <div style="font-size: 0.9em; color: var(--text);">
            <span id="uploadProgressText">Uploading...</span>
            <span id="uploadTimeRemaining" style="margin-left: 1rem; color: #999;"></span>
          </div>
          <div style="font-size: 0.9em; color: var(--text);">
            <span id="uploadProgressPercent">0%</span>
          </div>
        </div>
        <div style="width: 100%; height: 8px; background: var(--input-bg); border-radius: 4px; overflow: hidden;">
          <div id="uploadProgressBar" style="height: 100%; background: var(--success); width: 0%; transition: width 0.3s ease;"></div>
        </div>
      </div>

    </div>

    <!-- ============================================================================= -->
    <!-- CONSOLE WINDOW (For Troubleshooting) -->
    <!-- ============================================================================= -->
    <div class="section-frame">
      <div class="section-title">Console</div>
      <div class="console-output" id="console"></div>
    </div>
  </div>

  <script>
    const APP_VERSION = 'v0.5.27';
    const DEFAULTS = {
      company: "Nike",
      website: "nike.com",
      count: 30,
      sites: "nike.com, amazon.com",
      images_per_item: 3,
      prefix: "https://res.cloudinary.com/com-manh-cp/image/upload/v1752528139/sidney/",
      upload_folder: "sidney",
      upload_profile: "",
      extra_prompt: "",
      image_filters: "",
      existing_list: "items.txt",
      csv_out: "imagedownload.csv",
      save_dir: "/tmp/images"
    };

    let generatedProducts = [];
    let generatedOutputText = '';
    let referenceItems = [];
    let currentItemList = [];
    let itemListCollapsed = false;
    let galleryItems = [];
    let gallerySelections = {};
    let gallerySkippedItems = new Set(); // Track skipped items
    let galleryNewImages = new Map(); // Track new images per item: Map<itemId, Set<fileName>>
    let galleryMissingItems = [];
    let lastGalleryPayload = null;
    let galleryLoading = false;
    let gallerySliderPositions = {}; // Track slider positions per item: Map<uniqueKey, index>
    let csvData = null;
    let loadedCsvData = null; // CSV data from loaded file
    let sessionOrg = null; // ORG stored in session (resets on refresh)
    let sessionToken = null; // Token stored in session (resets on refresh)
    let orgFromUrl = false; // Flag to track if ORG came from URL
    let fullScriptContent = '';
    let carouselGroup = null;
    let carouselIndex = 0;

    function loadConfig() {
      const config = {};
      for (const key in DEFAULTS) {
        const stored = localStorage.getItem(`item_gen_${key}`);
        config[key] = stored !== null ? stored : DEFAULTS[key];
      }
      return config;
    }

    function saveConfig() {
      const config = {
        company: document.getElementById('company').value,
        website: document.getElementById('website').value,
        count: document.getElementById('count').value,
        sites: document.getElementById('sites').value,
        images_per_item: document.getElementById('images_per_item').value,
        prefix: document.getElementById('prefix').value,
        upload_folder: document.getElementById('upload_folder').value,
        upload_profile: document.getElementById('upload_profile').value,
        extra_prompt: document.getElementById('extra_prompt').value,
        image_filters: document.getElementById('image_filters').value,
        existing_list: document.getElementById('existing_list').value,
        csv_out: document.getElementById('csv_out').value,
        save_dir: document.getElementById('save_dir').value
      };

      for (const key in config) {
        if (config[key]) {
          localStorage.setItem(`item_gen_${key}`, config[key]);
        }
      }
    }

    function getDesktopPath() {
      if (navigator.platform.toLowerCase().includes('win')) {
        return 'C:\\Users\\User\\Desktop\\';
      } else if (navigator.platform.toLowerCase().includes('mac')) {
        return '~/Desktop/';
      }
      return '~/Desktop/';
    }

    function normalizePathDefaults(config) {
      const hasStoredConfig = Object.keys(localStorage).some(key => key.startsWith('item_gen_'));
      if (hasStoredConfig) return config;
        const desktopPath = getDesktopPath();
        if (config.existing_list && !config.existing_list.includes('/') && !config.existing_list.includes('\\')) {
          config.existing_list = desktopPath + config.existing_list;
        }
        if (config.csv_out && !config.csv_out.includes('/') && !config.csv_out.includes('\\')) {
          config.csv_out = desktopPath + config.csv_out;
        }
        if (!config.save_dir || config.save_dir === DEFAULTS.save_dir) {
          config.save_dir = '';
        }
      return config;
      }

    // Function to filter image files (shared by preview and upload) - defined at global scope
    function filterImageFiles(files, includeSubfolders) {
        console.log('üîç [FILTER] Starting filterImageFiles');
        console.log('üîç [FILTER] Parameters:', { 
          totalFiles: files ? files.length : 0, 
          includeSubfolders: includeSubfolders 
        });
        
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
        let totalFiles = 0;
        let rootFiles = 0;
        let subfolderFiles = 0;
        let nonImageFiles = 0;
        let filteredRootFiles = 0;
        let filteredSubfolderFiles = 0;
        
        const filtered = Array.from(files).filter((file, index) => {
          totalFiles++;
          
          // Log first 5 files for debugging
          if (index < 5) {
            console.log(`üîç [FILTER] File ${index + 1}:`, {
              name: file.name,
              webkitRelativePath: file.webkitRelativePath || '(none)',
              size: file.size,
              type: file.type
            });
          }
          
          // Check file extension
          const ext = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
          if (!imageExtensions.includes(ext)) {
            nonImageFiles++;
            if (index < 5) {
              console.log(`üîç [FILTER] File ${index + 1} rejected: not an image (ext: ${ext})`);
            }
            return false;
          }
          
          // If subfolders not included, exclude files that are in subfolders
          if (!includeSubfolders && file.webkitRelativePath) {
            const relativePath = file.webkitRelativePath;
            const pathSegments = relativePath.split('/');
            // When selecting a folder with webkitdirectory, the path includes the folder name:
            // Root files: webkitRelativePath = "images/filename.jpg" (2 segments: folder + filename)
            // Subfolder files: webkitRelativePath = "images/Saved/filename.jpg" (3+ segments: folder + subfolder + filename)
            // So: 2 segments = root file, 3+ segments = subfolder file
            const isInSubfolder = pathSegments.length > 2;
            
            if (index < 5) {
              console.log(`üîç [FILTER] File ${index + 1} path analysis:`, {
                relativePath: relativePath,
                pathSegments: pathSegments,
                segmentCount: pathSegments.length,
                isInSubfolder: isInSubfolder,
                filename: pathSegments[pathSegments.length - 1],
                folderName: pathSegments[0]
              });
            }
            
            if (isInSubfolder) {
              subfolderFiles++;
              if (index < 5) {
                console.log(`üîç [FILTER] File ${index + 1} rejected: in subfolder (includeSubfolders=false) - path has ${pathSegments.length} segment(s):`, pathSegments);
              }
              return false; // File is in a subfolder
            } else {
              rootFiles++;
              filteredRootFiles++;
              if (index < 5) {
                console.log(`üîç [FILTER] File ${index + 1} accepted: root file - path has ${pathSegments.length} segment(s): "${relativePath}"`);
              }
            }
          } else if (includeSubfolders) {
            // If including subfolders, count all files
            // 2 segments = root file, 3+ segments = subfolder file
            if (file.webkitRelativePath) {
              const segmentCount = file.webkitRelativePath.split('/').length;
              if (segmentCount > 2) {
                subfolderFiles++;
                filteredSubfolderFiles++;
              } else {
                rootFiles++;
                filteredRootFiles++;
              }
            } else {
              rootFiles++;
              filteredRootFiles++;
            }
          } else {
            // No webkitRelativePath (shouldn't happen with webkitdirectory, but handle it)
            rootFiles++;
            filteredRootFiles++;
          }
          
          return true;
        });
        
        console.log('üîç [FILTER] Filtering complete:', {
          totalFiles: totalFiles,
          filteredCount: filtered.length,
          rootFiles: rootFiles,
          subfolderFiles: subfolderFiles,
          nonImageFiles: nonImageFiles,
          filteredRootFiles: filteredRootFiles,
          filteredSubfolderFiles: filteredSubfolderFiles,
          includeSubfolders: includeSubfolders
        });
        
        return filtered;
      }

    function initUI() {
      let config = loadConfig();
      config = normalizePathDefaults(config);

      // Helper function to update red shading on file input textboxes
      // This function manages the red shading based on whether the textbox is empty
      function updateFileInputShading(element, isEmpty) {
        if (!element) return;
        if (isEmpty || !element.value || element.value.trim() === '') {
          // Apply red shading when empty
          element.style.setProperty('background-color', 'rgba(255, 0, 0, 0.1)', 'important');
          element.style.setProperty('border-color', 'rgba(255, 0, 0, 0.3)', 'important');
        } else {
          // Remove red shading when has value
          element.style.setProperty('background-color', '', 'important');
          element.style.setProperty('border-color', '', 'important');
        }
      }

      // Populate ALL fields from config first
      for (const key in config) {
        const el = document.getElementById(key);
        if (el) {
          el.value = config[key];
        }
      }

      // Now clear ONLY the 4 file input textboxes - user must load files each time
      // Red shading on textboxes indicates files need to be loaded
      // This happens AFTER all other fields are populated
      const existingListInput = document.getElementById('existing_list');
      const csvOutInput = document.getElementById('csv_out');
      const referenceItemsDisplay = document.getElementById('reference_items_display');
      const saveDirInput = document.getElementById('save_dir');
      
      // Only clear these 4 specific fields - nothing else
      if (existingListInput) {
        existingListInput.value = '';
        updateFileInputShading(existingListInput, true);
      }
      if (csvOutInput) {
        csvOutInput.value = '';
        updateFileInputShading(csvOutInput, true);
      }
      if (referenceItemsDisplay) {
        referenceItemsDisplay.value = '';
        updateFileInputShading(referenceItemsDisplay, true);
      }
      if (saveDirInput) {
        saveDirInput.value = '';
        updateFileInputShading(saveDirInput, true);
      }
      
      // Function to update image preview
      function updateImagePreview() {
        console.log('üìã [PREVIEW] updateImagePreview() called');
        
        const dirInput = document.getElementById('save_dir_file');
        const previewContainer = document.getElementById('imagePreviewContainer');
        const previewList = document.getElementById('imagePreviewList');
        const imageCount = document.getElementById('imageCount');
        
        console.log('üìã [PREVIEW] Elements found:', {
          dirInput: !!dirInput,
          previewContainer: !!previewContainer,
          previewList: !!previewList,
          imageCount: !!imageCount,
          filesCount: dirInput && dirInput.files ? dirInput.files.length : 0
        });
        
        if (!dirInput || !dirInput.files || dirInput.files.length === 0) {
          console.log('üìã [PREVIEW] No files selected, hiding preview');
          if (previewContainer) {
            previewContainer.style.display = 'none';
          }
          return;
        }
        
        const includeSubfoldersCheckbox = document.getElementById('include_subfolders');
        const includeSubfolders = includeSubfoldersCheckbox ? includeSubfoldersCheckbox.checked : false;
        
        console.log('üìã [PREVIEW] Checkbox state:', {
          checkboxExists: !!includeSubfoldersCheckbox,
          checked: includeSubfolders
        });
        
        console.log('üìã [PREVIEW] Calling filterImageFiles with', dirInput.files.length, 'files');
        const imageFiles = filterImageFiles(dirInput.files, includeSubfolders);
        
        if (!previewContainer || !previewList || !imageCount) {
          console.error('üìã [PREVIEW] ERROR: Preview elements not found');
          return;
        }
        
        if (imageFiles.length === 0) {
          console.log('üìã [PREVIEW] No image files after filtering, hiding preview');
          previewContainer.style.display = 'none';
          return;
        }
        
        // Show preview
        console.log('üìã [PREVIEW] Showing preview with', imageFiles.length, 'images');
        previewContainer.style.display = 'block';
        previewContainer.style.visibility = 'visible';
        imageCount.textContent = imageFiles.length;
        
        // Initialize selection state - all checked by default
        if (!window.imageSelectionState) {
          window.imageSelectionState = {};
        }
        
        // Reset selection state for new files (all checked by default)
        imageFiles.forEach(file => {
          const fileKey = file.webkitRelativePath || file.name;
          if (window.imageSelectionState[fileKey] === undefined) {
            window.imageSelectionState[fileKey] = true; // Default checked
          }
        });
        
        // Update selected count
        updateSelectedCount();
        
        // Scroll preview into view
        previewContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        
        // Prevent multiple simultaneous updates
        if (window.updatingPreview) {
          console.log('‚è∏Ô∏è [PREVIEW] Update already in progress, skipping...');
          return;
        }
        window.updatingPreview = true;
        
        // Auto-clear the flag after a reasonable timeout (2 seconds) as safety
        setTimeout(() => {
          if (window.updatingPreview) {
            console.log('‚ö†Ô∏è [PREVIEW] Update flag stuck, clearing it');
            window.updatingPreview = false;
          }
        }, 2000);
        
        // Build gallery view with thumbnails
        previewList.innerHTML = ''; // Clear first
        console.log('üßπ [GALLERY] Cleared preview list, starting to add', imageFiles.length, 'items');
        
        // Helper function to extract subfolder from path
        function getSubfolder(relativePath) {
          const parts = relativePath.split('/');
          if (parts.length > 2) {
            // Skip the first part (selected folder name) and last part (filename)
            return parts.slice(1, -1).join('/');
          }
          return null;
        }
        
        // Helper function to get just the filename
        function getFilename(relativePath) {
          const parts = relativePath.split('/');
          return parts[parts.length - 1];
        }
        
        // Create gallery items
        console.log('üé® [GALLERY] Starting to create', imageFiles.length, 'gallery items');
        let itemsCreated = 0;
        imageFiles.forEach((file, index) => {
          try {
            console.log(`üé® [GALLERY] Processing item ${index + 1}/${imageFiles.length}:`, file.name);
          const relativePath = file.webkitRelativePath || file.name;
          const fileKey = relativePath;
          const isChecked = window.imageSelectionState[fileKey] !== false; // Default true
          const itemId = `gallery_item_${index}`;
          const thumbnailId = `gallery_thumb_${index}`;
          const filename = getFilename(relativePath);
          const subfolder = getSubfolder(relativePath);
          
          // Create gallery item container
          const itemDiv = document.createElement('div');
          itemDiv.id = itemId;
          itemDiv.className = `gallery-item ${isChecked ? 'selected' : ''}`;
          itemDiv.setAttribute('data-file-key', fileKey);
          
          // Create thumbnail image
          const img = document.createElement('img');
          img.id = thumbnailId;
          img.className = 'gallery-thumbnail loading';
          img.alt = filename;
          // Don't use lazy loading for thumbnails in scrollable container - load immediately
          // img.loading = 'lazy';
          
          // Create object URL for the image
          try {
            const objectURL = URL.createObjectURL(file);
            console.log('üñºÔ∏è [GALLERY] Created object URL for:', filename);
            
            // Handle image load
            img.onload = function() {
              this.classList.remove('loading');
              console.log('‚úÖ [GALLERY] Image loaded successfully:', filename);
            };
            
            // Handle image load errors
            img.onerror = function() {
              console.error('‚ùå [GALLERY] Failed to load image:', filename, 'URL:', this.src);
              this.classList.remove('loading');
              // Show placeholder or error indicator
              this.style.background = 'var(--card-bg)';
              this.style.display = 'flex';
              this.style.alignItems = 'center';
              this.style.justifyContent = 'center';
              this.style.color = 'var(--text)';
              this.style.fontSize = '2em';
              this.textContent = 'üñºÔ∏è';
              this.alt = 'Failed to load: ' + filename;
            };
            
            // Set the src to trigger loading
            img.src = objectURL;
            
            // Debug: Check if image is in DOM and visible
            setTimeout(() => {
              console.log('üîç [GALLERY] Image check for:', filename, {
                inDOM: document.body.contains(img),
                src: img.src.substring(0, 50),
                complete: img.complete,
                naturalWidth: img.naturalWidth,
                naturalHeight: img.naturalHeight
              });
            }, 100);
          } catch (error) {
            console.error('‚ùå [GALLERY] Error creating object URL for:', filename, error);
            img.onerror();
          }
          
          // Create info section
          const infoDiv = document.createElement('div');
          infoDiv.className = 'gallery-info';
          
          const filenameDiv = document.createElement('div');
          filenameDiv.className = 'gallery-filename';
          filenameDiv.textContent = filename;
          
          infoDiv.appendChild(filenameDiv);
          
          if (subfolder) {
            const subfolderDiv = document.createElement('div');
            subfolderDiv.className = 'gallery-subfolder';
            subfolderDiv.textContent = `üìÅ ${subfolder}`;
            infoDiv.appendChild(subfolderDiv);
          }
          
          // Assemble item
          itemDiv.appendChild(img);
          itemDiv.appendChild(infoDiv);
          
          // Add click handler to toggle selection
          itemDiv.addEventListener('click', (e) => {
            // Allow clicking anywhere on the item to toggle
            const currentState = window.imageSelectionState[fileKey] !== false;
            const newState = !currentState;
            window.imageSelectionState[fileKey] = newState;
            
            // Update visual state
            if (newState) {
              itemDiv.classList.add('selected');
            } else {
              itemDiv.classList.remove('selected');
            }
            
            updateSelectedCount();
          });
          
          // Add to preview list
          previewList.appendChild(itemDiv);
          
          // Debug: Log each item being added
          console.log('üì¶ [GALLERY] Added gallery item:', {
            index: index,
            filename: filename,
            itemId: itemId,
            inDOM: document.body.contains(itemDiv),
            parent: itemDiv.parentElement?.id,
            itemWidth: itemDiv.offsetWidth,
            itemHeight: itemDiv.offsetHeight
          });
          
          // Store object URL for cleanup later
          if (!window.imageObjectURLs) {
            window.imageObjectURLs = [];
          }
          window.imageObjectURLs.push({ url: objectURL, fileKey: fileKey });
          
          itemsCreated++;
          console.log(`‚úÖ [GALLERY] Successfully created item ${index + 1}/${imageFiles.length} (${itemsCreated} total created so far)`);
          } catch (error) {
            console.error(`‚ùå [GALLERY] Error creating item ${index + 1}:`, error, file.name);
          }
        });
        
        console.log(`üéØ [GALLERY] forEach loop completed. Created ${itemsCreated} items out of ${imageFiles.length} total`);
        
        // Debug: Log final gallery state after a brief delay to allow rendering
        setTimeout(() => {
          console.log('üé® [GALLERY] Gallery populated:', {
            totalItems: imageFiles.length,
            domItems: previewList.children.length,
            gridStyle: window.getComputedStyle(previewList).display,
            gridColumns: window.getComputedStyle(previewList).gridTemplateColumns,
            containerWidth: previewList.offsetWidth,
            firstItemWidth: previewList.children[0]?.offsetWidth,
            firstItemPosition: previewList.children[0] ? window.getComputedStyle(previewList.children[0]).position : 'N/A'
          });
          
          // Log positions of first few items to check for overlap
          Array.from(previewList.children).slice(0, 3).forEach((item, idx) => {
            const rect = item.getBoundingClientRect();
            console.log(`üìç [GALLERY] Item ${idx} position:`, {
              left: rect.left,
              top: rect.top,
              width: rect.width,
              height: rect.height
            });
          });
        }, 200);
        
        // Cleanup old object URLs when preview is updated
        if (window.imageObjectURLs) {
          window.imageObjectURLs.forEach(item => {
            URL.revokeObjectURL(item.url);
          });
          window.imageObjectURLs = [];
        }
        
        // Clear the updating flag now that we're done
        window.updatingPreview = false;
        console.log('‚úÖ [PREVIEW] Preview update completed, flag cleared');
        
        console.log('üìã [PREVIEW] Preview updated successfully:', {
          imageCount: imageFiles.length,
          previewVisible: previewContainer.style.display,
          domItems: previewList.children.length
        });
      }
      
      // Function to update selected count display
      function updateSelectedCount() {
        const selectedCountEl = document.getElementById('selectedCount');
        if (!selectedCountEl || !window.imageSelectionState) return;
        
        const dirInput = document.getElementById('save_dir_file');
        if (!dirInput || !dirInput.files || dirInput.files.length === 0) {
          selectedCountEl.textContent = '0';
          return;
        }
        
        const includeSubfoldersCheckbox = document.getElementById('include_subfolders');
        const includeSubfolders = includeSubfoldersCheckbox ? includeSubfoldersCheckbox.checked : false;
        const imageFiles = filterImageFiles(dirInput.files, includeSubfolders);
        
        let selectedCount = 0;
        imageFiles.forEach(file => {
          const fileKey = file.webkitRelativePath || file.name;
          if (window.imageSelectionState[fileKey] !== false) {
            selectedCount++;
          }
        });
        
        selectedCountEl.textContent = selectedCount;
      }
      
      // Select All / Deselect All functions
      function selectAllImages() {
        const dirInput = document.getElementById('save_dir_file');
        if (!dirInput || !dirInput.files || !window.imageSelectionState) return;
        
        const includeSubfoldersCheckbox = document.getElementById('include_subfolders');
        const includeSubfolders = includeSubfoldersCheckbox ? includeSubfoldersCheckbox.checked : false;
        const imageFiles = filterImageFiles(dirInput.files, includeSubfolders);
        
        imageFiles.forEach((file) => {
          const fileKey = file.webkitRelativePath || file.name;
          window.imageSelectionState[fileKey] = true;
          
          // Update gallery item visual state by finding item with matching data attribute
          const previewList = document.getElementById('imagePreviewList');
          if (previewList) {
            const itemDiv = previewList.querySelector(`[data-file-key="${fileKey}"]`);
            if (itemDiv) {
              itemDiv.classList.add('selected');
            }
          }
        });
        
        updateSelectedCount();
      }
      
      function deselectAllImages() {
        const dirInput = document.getElementById('save_dir_file');
        if (!dirInput || !dirInput.files || !window.imageSelectionState) return;
        
        const includeSubfoldersCheckbox = document.getElementById('include_subfolders');
        const includeSubfolders = includeSubfoldersCheckbox ? includeSubfoldersCheckbox.checked : false;
        const imageFiles = filterImageFiles(dirInput.files, includeSubfolders);
        
        imageFiles.forEach((file) => {
          const fileKey = file.webkitRelativePath || file.name;
          window.imageSelectionState[fileKey] = false;
          
          // Update gallery item visual state by finding item with matching data attribute
          const previewList = document.getElementById('imagePreviewList');
          if (previewList) {
            const itemDiv = previewList.querySelector(`[data-file-key="${fileKey}"]`);
            if (itemDiv) {
              itemDiv.classList.remove('selected');
            }
          }
        });
        
        updateSelectedCount();
      }
      
      // Handle directory selection - use both change and input events for maximum compatibility
      const dirInput = document.getElementById('save_dir_file');
      
      // Store previous file count to detect changes
      let previousFileCount = 0;
      
      function handleDirectorySelection(e) {
        console.log('üìÅ [DIRECTORY] Directory selection event fired');
        console.log('üìÅ [DIRECTORY] Event type:', e.type);
        console.log('üìÅ [DIRECTORY] Target:', e.target);
        
        const target = e.target || dirInput;
        const files = target.files;
        const filesLength = files ? files.length : 0;
        
        console.log('üìÅ [DIRECTORY] Files selected:', filesLength);
        console.log('üìÅ [DIRECTORY] Files object:', files);
        console.log('üìÅ [DIRECTORY] Input element:', {
          id: target.id,
          type: target.type,
          hasWebkitDirectory: target.hasAttribute('webkitdirectory'),
          hasDirectory: target.hasAttribute('directory')
        });
        
        // Small delay to ensure files are fully loaded
        setTimeout(() => {
          const filesAfterDelay = target.files;
          const filesLengthAfterDelay = filesAfterDelay ? filesAfterDelay.length : 0;
          
          console.log('üìÅ [DIRECTORY] Files after delay:', filesLengthAfterDelay);
          
          if (!filesAfterDelay || filesLengthAfterDelay === 0) {
            console.log('üìÅ [DIRECTORY] No files selected, updating preview');
            // User cancelled or no files selected - apply red shading
            const saveDirInput = document.getElementById('save_dir');
            if (saveDirInput) {
              saveDirInput.value = '';
              updateFileInputShading(saveDirInput, true);
            }
            updateImagePreview();
            return;
          }
          
          console.log('üìÅ [DIRECTORY] Processing', filesLengthAfterDelay, 'files');
          
          const firstFile = filesAfterDelay[0];
          console.log('üìÅ [DIRECTORY] First file info:', {
            name: firstFile.name,
            webkitRelativePath: firstFile.webkitRelativePath || '(none)',
            size: firstFile.size,
            type: firstFile.type
          });
          
          // Log a few more files to understand the path structure
          console.log('üìÅ [DIRECTORY] Sample file paths (first 5):');
          for (let i = 0; i < Math.min(5, filesAfterDelay.length); i++) {
            const file = filesAfterDelay[i];
            const pathParts = file.webkitRelativePath ? file.webkitRelativePath.split('/') : [];
            console.log(`  File ${i + 1}: "${file.webkitRelativePath}" ‚Üí ${pathParts.length} segment(s):`, pathParts);
          }
          
          let dirPath = '';
          if (firstFile.webkitRelativePath) {
            // Extract directory path from webkitRelativePath
            // For root files: webkitRelativePath = "filename.jpg", dirPath = ""
            // For subfolder files: webkitRelativePath = "subfolder/filename.jpg", dirPath = "subfolder"
            // NOTE: When selecting a folder, webkitRelativePath might include the folder name itself
            const parts = firstFile.webkitRelativePath.split('/');
            console.log('üìÅ [DIRECTORY] Path parts:', parts);
            console.log('üìÅ [DIRECTORY] Path analysis:', {
              fullPath: firstFile.webkitRelativePath,
              parts: parts,
              partCount: parts.length,
              filename: parts[parts.length - 1],
              isRootFile: parts.length === 1
            });
            
            if (parts.length > 1) {
              parts.pop(); // Remove filename
            dirPath = parts.join('/');
            }
          } else if (firstFile.path) {
            const parts = firstFile.path.split(/[/\\]/);
            parts.pop();
            dirPath = parts.join('/');
          }
          
          const saveDirInput = document.getElementById('save_dir');
          if (saveDirInput) {
            if (dirPath) {
              saveDirInput.value = dirPath;
              console.log('üìÅ [DIRECTORY] Set directory path to:', dirPath);
            } else {
              // Root directory selected
              saveDirInput.value = 'Root';
              console.log('üìÅ [DIRECTORY] Root directory selected');
            }
            // Remove red shading when directory is successfully selected
            updateFileInputShading(saveDirInput, false);
          }
          
          // Always update preview when directory changes
          console.log('üìÅ [DIRECTORY] Calling updateImagePreview() with', files.length, 'files');
          updateImagePreview();
        }, 100);
      }
      
      // Listen to both change and input events
      dirInput.addEventListener('change', (e) => {
        console.log('üìÅ [DIRECTORY] ‚ö° CHANGE EVENT FIRED!');
        console.log('üìÅ [DIRECTORY] Change event details:', {
          type: e.type,
          target: e.target,
          filesCount: e.target.files ? e.target.files.length : 0,
          timestamp: new Date().toISOString()
        });
        handleDirectorySelection(e);
      });
      
      dirInput.addEventListener('input', (e) => {
        console.log('üìÅ [DIRECTORY] ‚ö° INPUT EVENT FIRED!');
        console.log('üìÅ [DIRECTORY] Input event details:', {
          type: e.type,
          target: e.target,
          filesCount: e.target.files ? e.target.files.length : 0,
          timestamp: new Date().toISOString()
        });
        handleDirectorySelection(e);
      });
      
      // Also listen for any other file-related events
      ['focus', 'blur'].forEach(eventType => {
        dirInput.addEventListener(eventType, (e) => {
          console.log(`üìÅ [DIRECTORY] Input ${eventType} event:`, {
            filesCount: e.target.files ? e.target.files.length : 0
          });
        });
      });
      
      // Track when dialog opens/closes - this is key for Windows folder picker
      let dialogOpen = false;
      let focusCheckTimeouts = [];
      
      // Track when window loses focus (dialog opens)
      window.addEventListener('blur', () => {
        console.log('üìÅ [DIRECTORY] Window lost focus - dialog likely opened');
        dialogOpen = true;
      });
      
      // Check when window regains focus (native dialog closes)
      window.addEventListener('focus', () => {
        console.log('üìÅ [DIRECTORY] Window regained focus - dialog likely closed');
        
        // Clear any existing timeouts
        focusCheckTimeouts.forEach(clearTimeout);
        focusCheckTimeouts = [];
        
        if (dialogOpen) {
          dialogOpen = false;
          
          // Check multiple times with increasing delays to catch files being set
          [50, 100, 200, 300, 500, 750, 1000, 1500, 2000].forEach((delay, index) => {
            const timeout = setTimeout(() => {
              const currentCount = dirInput.files ? dirInput.files.length : 0;
              console.log(`üìÅ [DIRECTORY] Focus check ${index + 1} (${delay}ms):`, currentCount, 'files');
              
              if (currentCount > 0 && currentCount !== previousFileCount) {
                console.log('üìÅ [DIRECTORY] Files detected after focus!', currentCount);
                previousFileCount = currentCount;
                handleDirectorySelection({ type: 'focus', target: dirInput });
                // Clear remaining timeouts since we found the files
                focusCheckTimeouts.forEach(clearTimeout);
                focusCheckTimeouts = [];
              }
            }, delay);
            focusCheckTimeouts.push(timeout);
          });
        }
      });
      
      // Also check when page becomes visible again (handles tab switching)
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden && dialogOpen) {
          console.log('üìÅ [DIRECTORY] Page became visible - checking for files');
          setTimeout(() => {
            const currentCount = dirInput.files ? dirInput.files.length : 0;
            if (currentCount > 0 && currentCount !== previousFileCount) {
              console.log('üìÅ [DIRECTORY] Files detected after visibility change!', currentCount);
              previousFileCount = currentCount;
              handleDirectorySelection({ type: 'visibility', target: dirInput });
            }
          }, 200);
        }
      });
      
      // Track when directory picker is opened - use ID selector for reliability
      const chooseDirBtn = document.getElementById('chooseDirBtn');
      if (chooseDirBtn) {
        chooseDirBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('üìÅ [DIRECTORY] Choose Directory button clicked - opening native dialog');
          checkingFiles = true;
          previousFileCount = dirInput.files ? dirInput.files.length : 0;
          console.log('üìÅ [DIRECTORY] Current file count before selection:', previousFileCount);
          
          // Trigger the file input click
          dirInput.click();
          
          // Set up aggressive polling right after click (before dialog even closes)
          const pollDelays = [500, 1000, 1500, 2000, 2500, 3000];
          pollDelays.forEach((delay, index) => {
            setTimeout(() => {
              const currentCount = dirInput.files ? dirInput.files.length : 0;
              console.log(`üìÅ [DIRECTORY] Post-click check ${index + 1} (${delay}ms):`, currentCount, 'files');
              if (currentCount > 0 && currentCount !== previousFileCount) {
                console.log('üìÅ [DIRECTORY] Files detected in post-click check!', currentCount);
                previousFileCount = currentCount;
                handleDirectorySelection({ type: 'post-click', target: dirInput });
              }
            }, delay);
          });
        });
      } else {
        console.error('üìÅ [DIRECTORY] Choose Directory button not found!');
      }
      
      // Also check periodically if files were added (fallback for some browsers)
      const pollInterval = setInterval(() => {
        const currentCount = dirInput.files ? dirInput.files.length : 0;
        if (currentCount !== previousFileCount && currentCount > 0) {
          console.log('üìÅ [DIRECTORY] File count changed via polling:', currentCount, '(was', previousFileCount, ')');
          previousFileCount = currentCount;
          handleDirectorySelection({ type: 'polling', target: dirInput });
        }
      }, 1000);
      
      // Expose a manual check function for debugging
      window.checkDirectoryFiles = function() {
        console.log('üìÅ [DIRECTORY] Manual check triggered');
        console.log('üìÅ [DIRECTORY] Input element:', dirInput);
        console.log('üìÅ [DIRECTORY] Input.files:', dirInput.files);
        console.log('üìÅ [DIRECTORY] Input.files.length:', dirInput.files ? dirInput.files.length : 'N/A');
        console.log('üìÅ [DIRECTORY] Input.files is FileList?', dirInput.files instanceof FileList);
        
        const currentCount = dirInput.files ? dirInput.files.length : 0;
        console.log('üìÅ [DIRECTORY] Current file count:', currentCount);
        console.log('üìÅ [DIRECTORY] Previous file count:', previousFileCount);
        
        if (dirInput.files && dirInput.files.length > 0) {
          console.log('üìÅ [DIRECTORY] First file:', {
            name: dirInput.files[0].name,
            webkitRelativePath: dirInput.files[0].webkitRelativePath,
            size: dirInput.files[0].size
          });
        }
        
        if (currentCount > 0) {
          console.log('üìÅ [DIRECTORY] Files found! Triggering handler...');
          previousFileCount = currentCount;
          handleDirectorySelection({ type: 'manual', target: dirInput });
        } else {
          console.log('üìÅ [DIRECTORY] No files found in input element');
          console.log('üìÅ [DIRECTORY] Possible reasons:');
          console.log('  - Dialog was cancelled');
          console.log('  - No folder was selected');
          console.log('  - Browser security restriction');
          console.log('  - webkitdirectory not supported');
        }
      };
      
      console.log('üìÅ [DIRECTORY] Directory selection handler initialized. Use checkDirectoryFiles() in console to manually check.');
      
      // Update preview when subfolders checkbox changes
      document.getElementById('include_subfolders').addEventListener('change', (e) => {
        console.log('‚òëÔ∏è [CHECKBOX] Include subfolders changed:', e.target.checked);
        updateImagePreview();
        updateSelectedCount();
      });
      
      // Select All / Deselect All button handlers
      const selectAllBtn = document.getElementById('selectAllImages');
      const deselectAllBtn = document.getElementById('deselectAllImages');
      if (selectAllBtn) {
        selectAllBtn.addEventListener('click', selectAllImages);
      }
      if (deselectAllBtn) {
        deselectAllBtn.addEventListener('click', deselectAllImages);
      }

      // CSV Output file picker button
      const csvOutLoadBtn = document.getElementById('csvOutLoadBtn');
      if (csvOutLoadBtn) {
        csvOutLoadBtn.addEventListener('click', () => {
          document.getElementById('csv_out_file').click();
        });
      }

      document.getElementById('csv_out_file').addEventListener('change', async (e) => {
        if (!e.target.files.length) {
          const csvOutInput = document.getElementById('csv_out');
          csvOutInput.value = '';
          updateFileInputShading(csvOutInput, true);
          setCsvOutStatus('');
          loadedCsvData = null; // Clear loaded CSV data
          localStorage.removeItem('item_gen_csv_out_filename');
          return;
        }
        const file = e.target.files[0];
        
        // Validate CSV file format
        const validation = await validateCsvFile(file);
        
        if (!validation.valid) {
          // Show error message
          setCsvOutStatus('');
          const csvOutInput = document.getElementById('csv_out');
          csvOutInput.value = '';
          // Restore red shading to indicate file needs to be loaded
          updateFileInputShading(csvOutInput, true);
          // Clear BOTH loaded CSV data AND downloaded CSV data to force user to reload or download again
          loadedCsvData = null;
          csvData = null;
          e.target.value = '';
          alert(`Invalid CSV file format: ${validation.error}`);
          return;
        }

        // File is valid, parse and store CSV data
        const csvOutInput = document.getElementById('csv_out');
        const fileName = file.name;
        // Try to get folder path - browsers don't expose full path, but we can show folder\filename format
        let displayPath = fileName;
        if (file.webkitRelativePath) {
          // If file has relative path, use it
          const pathParts = file.webkitRelativePath.split('/');
          if (pathParts.length > 1) {
            displayPath = pathParts.slice(0, -1).join('\\') + '\\' + pathParts[pathParts.length - 1];
          }
        }
        csvOutInput.value = displayPath;
        csvOutInput.title = fileName; // Tooltip shows filename on hover
        // Remove red shading when file is loaded
        updateFileInputShading(csvOutInput, false);
        setCsvOutStatus(`${validation.rowCount} rows loaded`);
        
        // Parse CSV data from file
        try {
          if (file.name.toLowerCase().endsWith('.csv')) {
            const text = await file.text();
            loadedCsvData = parseCsvToArray(text);
          } else {
            // Excel file - convert to CSV format
            const buffer = await file.arrayBuffer();
            const workbook = XLSX.read(buffer, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
            // Convert to same format as parseCsvToArray (skip header, split by comma)
            loadedCsvData = rows.slice(1).map(row => {
              if (Array.isArray(row)) {
                return row.map(cell => String(cell || '').trim());
              }
              return [];
            }).filter(row => row.length > 0 && row.some(cell => cell.length > 0));
          }
          
          // Clear csvData when a new CSV is successfully loaded manually
          // This ensures manually loaded CSV takes priority over downloaded CSV
          csvData = null;
        } catch (error) {
          console.error('Error parsing CSV file:', error);
          setCsvOutStatus('');
          alert(`Error parsing file: ${error.message || 'Failed to parse file. Please ensure the file is a valid CSV or Excel file.'}`);
          csvOutInput.value = '';
          updateFileInputShading(csvOutInput, true);
          // Clear BOTH loaded CSV data AND downloaded CSV data to force user to reload or download again
          loadedCsvData = null;
          csvData = null;
          e.target.value = '';
          return;
        }
        
        // Store filename in localStorage for persistence
        localStorage.setItem('item_gen_csv_out_filename', fileName);
        e.target.value = '';
      });

      // Reference Items file picker button
      const referenceItemsLoadBtn = document.getElementById('referenceItemsLoadBtn');
      const referenceItemsFileInput = document.getElementById('item_numbers_csv');
      const referenceItemsDisplayEl = document.getElementById('reference_items_display');
      
      if (referenceItemsLoadBtn && referenceItemsFileInput) {
        referenceItemsLoadBtn.addEventListener('click', () => {
          referenceItemsFileInput.click();
        });
      }
      
      referenceItemsFileInput.addEventListener('change', async (e) => {
        if (!e.target.files.length) {
          referenceItems = [];
          setItemNumbersStatus('');
          if (referenceItemsDisplayEl) {
            referenceItemsDisplayEl.value = '';
            updateFileInputShading(referenceItemsDisplayEl, true);
          }
          // Clear stored filename
          localStorage.removeItem('item_gen_reference_items_filename');
          return;
        }
        const file = e.target.files[0];
        const fileName = file.name;
        
        // Validate file format before loading
        const validation = await validateReferenceItemsFile(file);
        
        if (!validation.valid) {
          // Show error message
          setItemNumbersStatus('');
          
          if (referenceItemsDisplayEl) {
            referenceItemsDisplayEl.value = '';
            referenceItemsDisplayEl.removeAttribute('title');
            // Restore red shading to indicate file needs to be loaded
            updateFileInputShading(referenceItemsDisplayEl, true);
          }
          
          // Clear reference items data to force user to reload
          referenceItems = [];
          localStorage.removeItem('item_gen_reference_items_filename');
          e.target.value = '';
          alert(`Invalid file format: ${validation.error}`);
          return;
        }
        
        // File is valid, parse and store CSV data
        try {
          referenceItems = await parseReferenceItemsFile(file);
          
          // Update display textbox - show only filename (full path not available for security)
          if (referenceItemsDisplayEl) {
            // Try to get folder path - browsers don't expose full path, but we can show folder\filename format
            let displayPath = fileName;
            if (file.webkitRelativePath) {
              // If file has relative path, use it
              const pathParts = file.webkitRelativePath.split('/');
              if (pathParts.length > 1) {
                displayPath = pathParts.slice(0, -1).join('\\') + '\\' + pathParts[pathParts.length - 1];
              }
            }
            referenceItemsDisplayEl.value = displayPath;
            referenceItemsDisplayEl.title = fileName; // Tooltip shows filename on hover
            // Remove red shading when file is loaded
            updateFileInputShading(referenceItemsDisplayEl, false);
          }
          
          // Store filename only after successful parse
          localStorage.setItem('item_gen_reference_items_filename', fileName);
          
          // Use validation count if available, otherwise use parsed items count
          const itemCount = validation.itemCount || referenceItems.length;
          setItemNumbersStatus(
            itemCount > 0
              ? `${itemCount} reference items loaded`
              : 'No item IDs detected in the first column.'
          );
        } catch (error) {
          // File parsing failed - show error and restore red shading
          console.error('Error parsing reference items file:', error);
          setItemNumbersStatus('');
          
          if (referenceItemsDisplayEl) {
            referenceItemsDisplayEl.value = '';
            referenceItemsDisplayEl.removeAttribute('title');
            // Restore red shading to indicate file needs to be loaded
            updateFileInputShading(referenceItemsDisplayEl, true);
          }
          
          // Clear reference items data to force user to reload
          referenceItems = [];
          localStorage.removeItem('item_gen_reference_items_filename');
          e.target.value = '';
          alert(`Error loading file: ${error.message || 'Failed to parse file. Please ensure the file is a valid CSV or Excel file.'}`);
        }
      });

      const existingListBtn = document.getElementById('existingListLoadBtn');
      if (existingListBtn) {
        existingListBtn.addEventListener('click', () => {
          document.getElementById('items_file').click();
        });
      }

      document.getElementById('items_file').addEventListener('change', async (e) => {
        if (!e.target.files.length) {
          const existingListInput = document.getElementById('existing_list');
          existingListInput.value = '';
          existingListInput.removeAttribute('title');
          updateFileInputShading(existingListInput, true);
          setExistingListStatus('');
          localStorage.removeItem('item_gen_existing_list_filename');
          return;
        }
        const file = e.target.files[0];
        
        // Validate file format before loading
        const validation = await validateExistingListFile(file);
        
        if (!validation.valid) {
          // Show error message
          setExistingListStatus('');
          const existingListInput = document.getElementById('existing_list');
          existingListInput.value = '';
          existingListInput.removeAttribute('title');
          // Restore red shading to indicate file needs to be loaded
          updateFileInputShading(existingListInput, true);
          // Clear current item list data to force user to reload
          currentItemList = [];
          setItemList([], 'No items loaded', false);
          localStorage.removeItem('item_gen_existing_list_filename');
          e.target.value = '';
          alert(`Invalid file format: ${validation.error}\n\nPlease ensure the file is a .txt file with one item per line (plain text format).`);
          return;
        }

        // File is valid, update display and load items
        // Display only filename (browsers don't provide full path for security)
        const existingListInput = document.getElementById('existing_list');
        const fileName = file.name;
        // Try to get folder path - browsers don't expose full path, but we can show folder\filename format
        let displayPath = fileName;
        if (file.webkitRelativePath) {
          // If file has relative path, use it
          const pathParts = file.webkitRelativePath.split('/');
          if (pathParts.length > 1) {
            displayPath = pathParts.slice(0, -1).join('\\') + '\\' + pathParts[pathParts.length - 1];
          }
        } else {
          // Try to extract folder from file path if available (limited browser support)
          // For now, show just filename - user can see full path in tooltip
          displayPath = fileName;
        }
        
        existingListInput.value = displayPath;
        existingListInput.title = fileName; // Tooltip shows filename on hover
        // Remove red shading when file is loaded
        updateFileInputShading(existingListInput, false);
        // Auto-apply when loading from file - no warnings, display in white
        setItemList(validation.items, `${validation.count} items loaded from ${file.name}`, true);
        setExistingListStatus(`${validation.count} items loaded`);
        
        e.target.value = '';
      });

      // Add event listener to textarea to detect changes
      const itemListTextarea = document.getElementById('itemListTextarea');
      if (itemListTextarea) {
        itemListTextarea.addEventListener('input', checkForUnappliedChanges);
        itemListTextarea.addEventListener('paste', () => {
          // Delay check to allow paste to complete
          setTimeout(checkForUnappliedChanges, 10);
        });
      }

      document.getElementById('itemListApplyBtn').addEventListener('click', () => {
        const result = validateItemsFromTextarea();
        if (!result.success) {
          alert(`Invalid item list format: ${result.error}`);
        }
        // Visual indicators are cleared in setItemList -> updateItemListTextarea -> checkForUnappliedChanges
      });

      document.getElementById('itemListSaveBtn').addEventListener('click', () => {
        // Validate before saving (same validations as Validate List button)
        const result = validateItemsFromTextarea();
        if (!result.success) {
          alert(`Cannot save: ${result.error}`);
          return;
        }
        
        // If validation passes, get the content and save
        const textarea = document.getElementById('itemListTextarea');
        const content = textarea.value.trim().length ? textarea.value : currentItemList.join('\n');
        
        // Generate unique filename with YYMMDD-HHMM format
        const now = new Date();
        const year = now.getFullYear().toString().slice(-2);
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const timestamp = `${year}${month}${day}-${hours}${minutes}`;
        const fileName = `Items_${timestamp}.txt`;
        
        downloadTextFile(content, fileName);
        logToConsole(`Item List saved to file ${fileName}`, 'success');
      });

      document.getElementById('itemListClearBtn').addEventListener('click', () => {
        setItemList([], 'Item list cleared');
        setExistingListStatus('');
      });

      document.getElementById('itemListToggleBtn').addEventListener('click', toggleItemListPanel);

      setItemList([], 'No items loaded yet.');
      
      // Initialize change detection
      checkForUnappliedChanges();
    }

    async function parseReferenceItemsFile(file) {
      const extension = file.name.split('.').pop().toLowerCase();
      let items = [];
      if (extension === 'csv' || extension === 'txt') {
        const text = await file.text();
        text.split(/\r?\n/).forEach(line => {
          const value = line.split(',')[0].trim();
          if (value) items.push(value);
        });
      } else {
        const buffer = await file.arrayBuffer();
        const workbook = XLSX.read(buffer, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        rows.forEach(row => {
          const value = row && row[0] ? String(row[0]).trim() : '';
          if (value) items.push(value);
        });
      }
      return items;
    }

    function normalizeItemList(items) {
      const seen = new Set();
      const normalized = [];
      items.forEach(item => {
        const trimmed = item.trim();
        if (!trimmed) return;
        const key = trimmed.toLowerCase();
        if (!seen.has(key)) {
          seen.add(key);
          normalized.push(trimmed);
        }
      });
      return normalized;
    }


    function updateItemListTextarea(message, autoApply = false) {
      const textarea = document.getElementById('itemListTextarea');
      if (!textarea) return;
      
      textarea.value = currentItemList.join('\n');
      const status = document.getElementById('itemListStatus');
      status.textContent = message || (currentItemList.length ? `${currentItemList.length} items in list` : 'No items loaded yet.');
      // Clear unapplied changes visual indicators
      checkForUnappliedChanges();
    }

    function checkForUnappliedChanges() {
      const textarea = document.getElementById('itemListTextarea');
      const badge = document.getElementById('unappliedChangesBadge');
      const countSpan = document.getElementById('unappliedChangesCount');
      
      if (!textarea || !badge || !countSpan) return;
      
      const textareaValue = textarea.value.trim();
      const currentValue = currentItemList.join('\n');
      
      // Check if textarea differs from currentItemList
      const hasChanges = textareaValue !== currentValue;
      
      if (hasChanges) {
        // Count differences - compare line by line
        const textareaLines = textareaValue.split(/\r?\n/).filter(line => line.trim().length > 0);
        const currentLines = currentItemList.length;
        const originalLines = currentValue.split('\n').filter(line => line.trim().length > 0);
        const newLines = textareaValue.split(/\r?\n/).filter(line => line.trim().length > 0);
        
        // Count actual changes (added, removed, or modified lines)
        let changeCount = 0;
        const maxLen = Math.max(originalLines.length, newLines.length);
        for (let i = 0; i < maxLen; i++) {
          const orig = originalLines[i] || '';
          const newLine = newLines[i] || '';
          if (orig.trim() !== newLine.trim()) {
            changeCount++;
          }
        }
        changeCount = changeCount || Math.abs(newLines.length - originalLines.length) || 1;
        
        // Show badge
        badge.style.display = 'block';
        countSpan.textContent = changeCount;
        
        // Apply orange color to textarea text to match warning badge
        textarea.style.color = '#ffa500'; // Orange color matching the badge
      } else {
        // Hide badge and restore normal color
        badge.style.display = 'none';
        textarea.style.color = '#fff'; // Normal white color
      }
    }

    function validateItemsFromTextarea() {
      const textarea = document.getElementById('itemListTextarea');
      const textValue = textarea.value.trim();
      
      // Check if textarea is empty
      if (!textValue || textValue.length === 0) {
        return { success: false, error: 'Item list cannot be empty. Please enter at least one item.' };
      }
      
      // Parse items from textarea
      const items = textValue.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
      
      // Validate format
      const validation = validateItemListFormat(items);
      if (!validation.valid) {
        return { success: false, error: validation.error };
      }
      
      // Apply if valid
      setItemList(items, `Validated ${items.length} items from editor`);
      return { success: true };
    }

    function setItemList(items, statusMessage, autoApply = false) {
      currentItemList = normalizeItemList(items || []);
      updateItemListTextarea(statusMessage, autoApply);
    }

    async function loadItemsFromTextFile(file) {
      // This function is now primarily used for programmatic loading
      // The file validation and loading is handled in the change event listener
      if (!file) return;
      const text = await file.text();
      const items = text.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
      // Auto-apply when loading from file - no warnings, display in white
      setItemList(items, `${items.length} items loaded from ${file.name}`, true);
      setExistingListStatus(`${items.length} items loaded`);
    }

    function toggleItemListPanel() {
      const body = document.getElementById('itemListBody');
      const btn = document.getElementById('itemListToggleBtn');
      itemListCollapsed = !itemListCollapsed;
      if (itemListCollapsed) {
        body.style.display = 'none';
        btn.textContent = 'Show';
      } else {
        body.style.display = '';
        btn.textContent = 'Hide';
      }
    }

    function logToConsole(message, type = 'info') {
      const consoleEl = document.getElementById('console');
      const timestamp = new Date().toLocaleTimeString();
      const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : 'info';
      consoleEl.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }

    function base64ToBlob(base64Data, mimeType) {
      const byteCharacters = atob(base64Data);
      const byteNumbers = new Array(byteCharacters.length);
      for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
      }
      const byteArray = new Uint8Array(byteNumbers);
      return new Blob([byteArray], { type: mimeType });
    }

    function downloadBase64File(base64Data, fileName, mimeType) {
      const blob = base64ToBlob(base64Data, mimeType);
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
    }

    function downloadTextFile(content, fileName) {
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
    }

    function setItemNumbersStatus(text) {
      document.getElementById('itemNumbersStatus').textContent = text || '';
    }

    function setExistingListStatus(text) {
      document.getElementById('existingListStatus').textContent = text || '';
    }

    function setCsvOutStatus(text) {
      document.getElementById('csvOutStatus').textContent = text || '';
    }

    async function validateCsvFile(file) {
      if (!file) {
        return { valid: false, error: 'No file selected' };
      }

      const extension = file.name.split('.').pop().toLowerCase();
      if (!['csv', 'xls', 'xlsx'].includes(extension)) {
        return { valid: false, error: 'File must be a CSV or Excel file (.csv, .xls, .xlsx)' };
      }

      try {
        let rows = [];
        
        if (extension === 'csv') {
          const text = await file.text();
          rows = text.split(/\r?\n/).map(line => {
            // Parse CSV line (handle quoted values)
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              if (char === '"') {
                inQuotes = !inQuotes;
              } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
              } else {
                current += char;
              }
            }
            result.push(current.trim());
            return result;
          }).filter(row => row.some(cell => cell.length > 0)); // Filter empty rows
        } else {
          // Excel file
          const buffer = await file.arrayBuffer();
          const workbook = XLSX.read(buffer, { type: 'array' });
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
          rows = rows.map(row => Array.isArray(row) ? row.map(cell => String(cell || '').trim()) : []);
          rows = rows.filter(row => row.some(cell => cell.length > 0)); // Filter empty rows
        }

        if (rows.length === 0) {
          return { valid: false, error: 'File is empty or contains no data rows' };
        }

        // Check if we have at least a header row and one data row
        if (rows.length < 2) {
          return { valid: false, error: 'File must contain at least one data row (excluding header)' };
        }

        // Check if we have at least 4 columns
        const maxColumns = Math.max(...rows.map(row => row.length));
        if (maxColumns < 4) {
          return { valid: false, error: `File must have at least 4 columns. Found ${maxColumns} column(s).` };
        }

        // Validate that all data rows (excluding header) have data in the first 4 columns
        const headerRow = rows[0];
        const dataRows = rows.slice(1); // All rows except header
        
        // Check each data row
        const invalidRows = [];
        dataRows.forEach((row, index) => {
          // Check if first 4 columns have data (not empty/whitespace)
          const requiredColumns = row.slice(0, 4);
          const hasEmptyColumn = requiredColumns.some((cell, colIndex) => {
            const cellValue = String(cell || '').trim();
            return cellValue.length === 0;
          });
          
          if (hasEmptyColumn) {
            invalidRows.push(index + 2); // +2 because: +1 for header, +1 for 1-based row numbering
          }
        });

        if (invalidRows.length > 0) {
          const rowList = invalidRows.length <= 5 
            ? invalidRows.join(', ')
            : `${invalidRows.slice(0, 5).join(', ')} and ${invalidRows.length - 5} more`;
          return { 
            valid: false, 
            error: `Invalid data: ${invalidRows.length} row(s) have empty values in required columns (first 4 columns). Rows with issues: ${rowList}. All rows must have data in the first 4 columns.` 
          };
        }

        // Count data rows (excluding header)
        const dataRowCount = dataRows.length;

        return { valid: true, rowCount: dataRowCount };
      } catch (error) {
        return { valid: false, error: `Error reading file: ${error.message}` };
      }
    }

    async function validateReferenceItemsFile(file) {
      if (!file) {
        return { valid: false, error: 'No file selected' };
      }

      const extension = file.name.split('.').pop().toLowerCase();
      if (!['csv', 'txt', 'xls', 'xlsx'].includes(extension)) {
        return { valid: false, error: 'File must be a CSV, TXT, or Excel file (.csv, .txt, .xls, .xlsx)' };
      }

      try {
        let rows = [];
        
        if (extension === 'csv' || extension === 'txt') {
          const text = await file.text();
          rows = text.split(/\r?\n/).map(line => {
            // Parse CSV line (handle quoted values)
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              if (char === '"') {
                inQuotes = !inQuotes;
              } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
              } else {
                current += char;
              }
            }
            result.push(current.trim());
            return result;
          }).filter(row => row.some(cell => cell.length > 0)); // Filter empty rows
        } else {
          // Excel file
          const buffer = await file.arrayBuffer();
          const workbook = XLSX.read(buffer, { type: 'array' });
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
          rows = rows.map(row => Array.isArray(row) ? row.map(cell => String(cell || '').trim()) : []);
          rows = rows.filter(row => row.some(cell => cell.length > 0)); // Filter empty rows
        }

        if (rows.length === 0) {
          return { valid: false, error: 'File is empty or contains no data rows' };
        }

        // Validate that first column has item IDs and column E (fifth column) is empty
        const invalidRows = [];
        const rowsWithDataInColumnE = [];
        
        rows.forEach((row, index) => {
          const rowNum = index + 1; // 1-based row numbering
          const firstColumn = row[0] ? String(row[0]).trim() : '';
          const fifthColumn = row[4] ? String(row[4]).trim() : ''; // Column E (index 4)
          
          // Check if first column is empty (invalid - no item ID)
          if (firstColumn.length === 0) {
            invalidRows.push(rowNum);
          }
          
          // Check if column E has data (should be empty for reference items file)
          if (fifthColumn.length > 0) {
            rowsWithDataInColumnE.push(rowNum);
          }
        });

        if (invalidRows.length > 0) {
          const rowList = invalidRows.length <= 5 
            ? invalidRows.join(', ')
            : `${invalidRows.slice(0, 5).join(', ')} and ${invalidRows.length - 5} more`;
          return { 
            valid: false, 
            error: `Invalid file: ${invalidRows.length} row(s) have empty values in the first column (Item ID). Rows with issues: ${rowList}. All rows must have an item ID in the first column.` 
          };
        }

        if (rowsWithDataInColumnE.length > 0) {
          const rowList = rowsWithDataInColumnE.length <= 5 
            ? rowsWithDataInColumnE.join(', ')
            : `${rowsWithDataInColumnE.slice(0, 5).join(', ')} and ${rowsWithDataInColumnE.length - 5} more`;
          return { 
            valid: false, 
            error: `Invalid file format: Column E (fifth column) should be empty for Reference Items File. Found data in column E on ${rowsWithDataInColumnE.length} row(s): ${rowList}. This may indicate the wrong spreadsheet was uploaded (e.g., Output CSV file instead of Reference Items File).` 
          };
        }

        // Count valid item IDs
        const itemCount = rows.length;

        return { valid: true, itemCount: itemCount };
      } catch (error) {
        return { valid: false, error: `Error reading file: ${error.message}` };
      }
    }

    async function validateExistingListFile(file) {
      if (!file) {
        return { valid: false, error: 'No file selected' };
      }

      // Check file extension
      const extension = file.name.split('.').pop().toLowerCase();
      if (extension !== 'txt') {
        return { valid: false, error: 'File must be a .txt file. The Download Items feature expects a plain text file with one item per line.' };
      }

      try {
        const text = await file.text();
        const lines = text.split(/\r?\n/);
        const items = lines.map(line => line.trim()).filter(Boolean);

        if (items.length === 0) {
          return { valid: false, error: 'File is empty or contains no valid items. Expected one item per line.' };
        }

        // The Download Items logic expects simple text with one item per line
        // Validate that the format matches: one item per line, plain text (not CSV/Excel format)
        // Check for common issues that suggest wrong format:
        // - Multiple items per line (comma-separated or tab-separated)
        // - CSV header row
        const hasMultipleItemsPerLine = items.some(item => {
          // If a line has commas or tabs and appears to have multiple columns, it's likely CSV/Excel format
          if (item.includes('\t')) return true;
          if (item.includes(',')) {
            const parts = item.split(',').map(p => p.trim()).filter(Boolean);
            // If there are multiple non-empty parts, it might be CSV format
            if (parts.length > 1 && parts.every(p => p.length > 0)) return true;
          }
          return false;
        });

        if (hasMultipleItemsPerLine) {
          return { 
            valid: false, 
            error: 'File format appears invalid. Expected one item per line (plain text format). This file appears to be in CSV/Excel format. Please use a plain text file with one item per line.' 
          };
        }

        return { valid: true, items: items, count: items.length };
      } catch (error) {
        return { valid: false, error: `Error reading file: ${error.message}` };
      }
    }

    async function apiCall(endpoint, data) {
      // Use human-readable names for common endpoints
      const endpointDisplayName = endpoint === 'update_wm' ? 'Update WM' : 
                                  endpoint === 'app_opened' ? 'App Opened' :
                                  endpoint === 'auth' ? 'Auth' :
                                  endpoint === 'generate_items' ? 'Generate Items' : endpoint;
      
      try {
        logToConsole(`Calling ${endpointDisplayName}...`, 'info');
        const response = await fetch(`/api/${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        const result = await response.json();
        if (result.success) {
          // Don't log generic success for update_wm - handleWmUpdate will log detailed summary
          if (endpoint !== 'update_wm') {
            logToConsole(`${endpointDisplayName} Succeeded`, 'success');
          }
        } else {
          logToConsole(`${endpointDisplayName} failed: ${result.error}`, 'error');
        }
        return result;
      } catch (error) {
        logToConsole(`${endpointDisplayName} error: ${error.message}`, 'error');
        return { success: false, error: error.message };
      }
    }

    async function handleGenerateClick() {
      saveConfig();
      const company = document.getElementById('company').value.trim();
      if (!company) {
        alert('Company is required');
        return;
      }
      const website = document.getElementById('website').value.trim();
      // Validate Item Count - check raw input before applying defaults
      const countInput = document.getElementById('count').value.trim();
      if (!countInput || countInput === '') {
        alert('Item Count is required and must be greater than 0');
        return;
      }
      const count = parseInt(countInput);
      if (isNaN(count) || count <= 0) {
        alert('Item Count must be greater than 0');
        return;
      }
      const extra_prompt = document.getElementById('extra_prompt').value.trim();

      const genBtn = document.getElementById('genBtn');
      const genProgress = document.getElementById('genProgress');
      const genStatus = document.getElementById('genStatus');

      genBtn.disabled = true;
      genProgress.style.display = 'block';
      genStatus.textContent = 'Generating...';

      const result = await apiCall('generate_items', { company, website, count, extra_prompt });

      genBtn.disabled = false;
      genProgress.style.display = 'none';

      if (!result.success) {
        genStatus.textContent = `Error: ${result.error}`;
        return;
      }

      generatedProducts = result.products;
      // Auto-apply when generating items - no warnings, display in white
      setItemList(result.products, `${result.products.length} generated items ready for gallery.`, true);

      genStatus.textContent = `Generated ${result.count} products successfully!`;
    }

    function getSearchSource() {
      if (currentItemList.length) return currentItemList.slice();
      if (generatedProducts.length) return generatedProducts.slice();
      return referenceItems.slice();
    }

    function validateItemListFormat(items) {
      // Check if items array is empty
      if (!items || items.length === 0) {
        return { valid: false, error: 'Item list cannot be empty. Please enter at least one item.' };
      }

      // Validate format - same logic as validateExistingListFile
      // Check for common issues that suggest wrong format:
      // - Multiple items per line (comma-separated or tab-separated)
      // - CSV format indicators
      const hasMultipleItemsPerLine = items.some(item => {
        // If an item has tabs, it's likely tab-separated format
        if (item.includes('\t')) return true;
        // If an item has commas and appears to have multiple columns, it's likely CSV format
        if (item.includes(',')) {
          const parts = item.split(',').map(p => p.trim()).filter(Boolean);
          // If there are multiple non-empty parts, it might be CSV format
          if (parts.length > 1 && parts.every(p => p.length > 0)) return true;
        }
        return false;
      });

      if (hasMultipleItemsPerLine) {
        return { 
          valid: false, 
          error: 'File format appears invalid. Expected one item per line (plain text format). This file appears to be in CSV/Excel format. Please use a plain text file with one item per line.' 
        };
      }

      return { valid: true };
    }

    function validateCurrentItemListFormat() {
      // Validate format - same logic as validateExistingListFile
      // Assumes currentItemList is not empty (caller should check that first)
      return validateItemListFormat(currentItemList);
    }

    async function handleDownloadClick() {
      // Check for unapplied changes in textarea and auto-apply if they exist
      const textarea = document.getElementById('itemListTextarea');
      const textareaValue = textarea ? textarea.value.trim() : '';
      const currentValue = currentItemList.join('\n');
      const hasUnappliedChanges = textareaValue !== currentValue;
      
      if (hasUnappliedChanges) {
        // Auto-validate changes from textarea
        const validateResult = validateItemsFromTextarea();
        if (!validateResult.success) {
          alert(`Cannot proceed with download: ${validateResult.error}\n\nPlease fix the item list format and try again.`);
          return;
        }
        // Changes have been validated, continue with download
      }

      // First check if Current Item List is empty
      if (currentItemList.length === 0) {
        alert('Item list cannot be empty. Please load or generate items before downloading.');
        return;
      }

      // If Current Item List has items, validate the format
      const itemListValidation = validateCurrentItemListFormat();
      if (!itemListValidation.valid) {
        alert(`Invalid item list format: ${itemListValidation.error}`);
        return;
      }

      // Now check Reference Items
      if (!referenceItems.length) {
        alert('Please upload a Reference Items File before downloading images.');
        return;
      }

      const baseNames = getSearchSource();
      if (!baseNames.length) {
        alert('Please generate or load items before downloading images.');
        return;
      }

      saveConfig();
      const sites = document.getElementById('sites').value.trim() || DEFAULTS.sites;
      // Validate Images Per Item - check raw input before applying defaults
      const imagesPerItemInput = document.getElementById('images_per_item').value.trim();
      if (!imagesPerItemInput || imagesPerItemInput === '') {
        alert('Images Per Item is required and must be greater than 0');
        return;
      }
      const images_per_item = parseInt(imagesPerItemInput);
      if (isNaN(images_per_item) || images_per_item <= 0) {
        alert('Images Per Item must be greater than 0');
        return;
      }
      const prefix = document.getElementById('prefix').value.trim();
      const filter_str = document.getElementById('image_filters').value.trim();

      const productsForSearch = baseNames.slice();

      lastGalleryPayload = {
        products: productsForSearch,
        sites,
        images_per_item,
        prefix,
        item_numbers: referenceItems,
        image_filters: filter_str
      };

      const dlBtn = document.getElementById('dlBtn');
      const dlProgress = document.getElementById('dlProgress');
      const dlStatus = document.getElementById('dlStatus');

      dlBtn.disabled = true;
      dlProgress.style.display = 'block';
      dlStatus.textContent = 'Preparing gallery...';

      const result = await apiCall('gallery_generate', lastGalleryPayload);

      dlBtn.disabled = false;
      dlProgress.style.display = 'none';

      if (!result.success) {
        dlStatus.textContent = `Error: ${result.error || 'Unable to generate gallery'}`;
        return;
      }

      galleryItems = result.items || [];
      gallerySelections = {};
      gallerySkippedItems.clear(); // Clear skipped items for new gallery
      galleryNewImages.clear(); // Clear new images tracking for new gallery
      galleryMissingItems = result.missingItems || [];
      dlStatus.textContent = 'Gallery ready. Review and select one image per item.';
      openGalleryModal();
    }

    function openGalleryModal() {
      document.getElementById('galleryModal').classList.add('show');
      renderGallery();
      setGalleryStatus('Select one image per item, then click Download Selected Items.');
    }

    function closeGalleryModal() {
      document.getElementById('galleryModal').classList.remove('show');
      setGalleryStatus('');
    }

    function renderGallery() {
      const grid = document.getElementById('galleryGrid');
      grid.innerHTML = '';

      galleryItems.forEach((item, itemIndex) => {
        const group = document.createElement('div');
        group.className = 'gallery-group';

        const header = document.createElement('div');
        header.className = 'gallery-group-header';
        const displayTitle = item.productName || item.itemId;
        // Use unique key for skip state to prevent collisions when items share same itemId
        const uniqueKey = getUniqueKey(itemIndex, item.itemId);
        const isSkipped = gallerySkippedItems.has(uniqueKey);
        
        // Create header with item name on left
        const titleDiv = document.createElement('div');
        const h5 = document.createElement('h5');
        h5.textContent = displayTitle;
        // Add image count display next to item name
        const countSpan = document.createElement('span');
        countSpan.style.color = '#9aa4d3'; // Different color (matching source text color)
        countSpan.style.marginLeft = '0.5rem';
        countSpan.style.fontSize = '0.9em';
        countSpan.textContent = `(${item.variants.length})`;
        h5.appendChild(countSpan);
        titleDiv.appendChild(h5);
        
        // Create page indicator (will be updated by slider) - centered in header
        const pageIndicator = document.createElement('div');
        pageIndicator.className = 'gallery-page-indicator';
        pageIndicator.style.cssText = 'font-size: 0.75rem; color: #9aa4d3; position: absolute; left: 50%; transform: translateX(-50%);';
        pageIndicator.textContent = 'Page 1 of 1'; // Will be updated by updateSlider
        
        // Create controls (checkbox and refresh button) on right
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'gallery-controls';
        
        const skipCheckbox = document.createElement('input');
        skipCheckbox.type = 'checkbox';
        skipCheckbox.className = 'skip-checkbox';
        skipCheckbox.checked = isSkipped;
        skipCheckbox.title = 'Skip this item';
        skipCheckbox.addEventListener('change', () => {
          if (skipCheckbox.checked) {
            gallerySkippedItems.add(uniqueKey);
            // Clear selection if item is skipped (use unique key)
            delete gallerySelections[uniqueKey];
          } else {
            gallerySkippedItems.delete(uniqueKey);
          }
          renderGallery();
          updateGallerySummary();
          updateGalleryToolbar();
        });
        
        const refreshBtn = document.createElement('button');
        refreshBtn.className = 'refresh-btn';
        refreshBtn.type = 'button';
        refreshBtn.innerHTML = '<span>üîÑ</span> Add New Images';
        refreshBtn.title = 'Add new images for this item';
        refreshBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          await handleRefreshImages(item.itemId, refreshBtn);
        });
        
        controlsDiv.appendChild(skipCheckbox);
        controlsDiv.appendChild(refreshBtn);
        
        // Make header position relative so page indicator can be absolutely positioned
        header.style.position = 'relative';
        header.appendChild(titleDiv);
        header.appendChild(pageIndicator);
        header.appendChild(controlsDiv);
        
        if (isSkipped) {
          group.classList.add('skipped');
        }
        
        group.appendChild(header);

        if (item.variants.length === 0) {
          const empty = document.createElement('div');
          empty.className = 'gallery-empty';
          empty.textContent = 'No images returned for this item.';
          group.appendChild(empty);
          grid.appendChild(group);
          return;
        }

        const sliderWrapper = document.createElement('div');
        sliderWrapper.className = 'variant-slider';
        const prevBtn = document.createElement('button');
        prevBtn.className = 'slider-nav-btn slider-nav-prev';
        prevBtn.innerHTML = '&#8249;';
        const nextBtn = document.createElement('button');
        nextBtn.className = 'slider-nav-btn slider-nav-next';
        nextBtn.innerHTML = '&#8250;';
        const viewport = document.createElement('div');
        viewport.className = 'slider-viewport';
        const track = document.createElement('div');
        track.className = 'slider-track';

        item.variants.forEach((variant, idx) => {
          const card = document.createElement('div');
          card.className = 'gallery-card';
          // Use array index to create unique key - fixes collision when multiple items have same itemId
          const uniqueKey = `${itemIndex}_${item.itemId}`;
          const currentItemId = item.itemId;
          const currentFileName = variant.fileName;
          const isSelected = gallerySelections[uniqueKey] === currentFileName;
          if (isSelected) card.classList.add('selected');
          
          // Check if this is a new image
          const isNewImage = galleryNewImages.has(currentItemId) && 
                             galleryNewImages.get(currentItemId).has(variant.originalUrl);
          
          const newBadgeHtml = isNewImage ? '<div class="new-images-badge">NEW</div>' : '';
          
          card.innerHTML = `
            <div class="gallery-card-image" style="position: relative;">
              <img src="${variant.previewUrl || variant.originalUrl}" alt="${variant.fileName}">
              ${newBadgeHtml}
            </div>
            <div class="gallery-card-body">
              <div class="gallery-card-title">Variant ${idx + 1}</div>
              <div class="gallery-card-source">${variant.source || 'Unknown'}</div>
            </div>
            <button class="gallery-preview-btn" type="button">Preview</button>
          `;
          // Use unique key (itemIndex + itemId) to prevent collisions when items share same itemId
          card.addEventListener('click', () => toggleGallerySelection(uniqueKey, currentFileName, currentItemId));
          const previewBtn = card.querySelector('.gallery-preview-btn');
          previewBtn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            openVariantCarousel(item, idx);
          });
          track.appendChild(card);
        });

        viewport.appendChild(track);
        sliderWrapper.appendChild(prevBtn);
        sliderWrapper.appendChild(viewport);
        sliderWrapper.appendChild(nextBtn);
        // Restore saved slider position if it exists, otherwise start at 0
        // Note: This is only used on initial render. After that, sliderState.index is maintained in the closure
        const savedIndex = gallerySliderPositions[uniqueKey] || 0;
        const sliderState = { index: savedIndex, visible: 4, cardWidth: 210 }; // Updated to match new card width

        const updateSlider = () => {
          const card = track.querySelector('.gallery-card');
          if (card) {
            // getBoundingClientRect().width includes padding and border, but NOT margin
            // We need to add margin (3px on each side = 6px total) to get full card space
            const cardRect = card.getBoundingClientRect();
            const cardStyle = window.getComputedStyle(card);
            const marginLeft = parseFloat(cardStyle.marginLeft) || 0;
            const marginRight = parseFloat(cardStyle.marginRight) || 0;
            sliderState.cardWidth = cardRect.width + marginLeft + marginRight; // Full card width including margins
          }
          const gap = 8; // Match slider-track gap (0.5rem = 8px) - must match CSS gap value
          // viewport width is the slider-viewport (space between arrows), which is correct
          const viewportWidth = viewport.getBoundingClientRect().width;
          
          // Calculate how many cards fit fully in viewport (for scrolling by pages)
          // Total space per card = card width (including margins) + gap between cards
          const spacePerCard = sliderState.cardWidth + gap;
          // Remove artificial cap - let it calculate based on actual viewport width
          sliderState.visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
          
          // Max index: largest page boundary (multiple of visible) that doesn't exceed total variants
          // Example: 18 variants, 5 visible -> last page boundary = floor(17/5)*5 = 15 (shows variants 16-18)
          // Example: 12 variants, 5 visible -> last page boundary = floor(11/5)*5 = 10 (shows variants 11-12)
          // This ensures the last page starts at a proper page boundary (variant 1, 6, 11, 16, etc.)
          // NOTE: Pagination functions (arrows, adding new images) work correctly with this logic
          const lastPageBoundary = Math.floor((item.variants.length - 1) / sliderState.visible) * sliderState.visible;
          const maxIndex = Math.max(0, lastPageBoundary);
          
          // Helper function to align index to page boundaries (multiples of visible)
          // This ensures we always show full pages (variant 1, 6, 11, etc. in leftmost position)
          const alignToPageBoundary = (index, maxIdx, visible) => {
            // Align to the nearest page boundary (multiple of visible)
            // Round down to ensure we don't overshoot
            let aligned = Math.floor(index / visible) * visible;
            // Clamp to maxIndex (which is already a page boundary)
            return Math.min(aligned, maxIdx);
          };
          
          // Clamp index to valid range first
          sliderState.index = Math.min(sliderState.index, maxIndex);
          
          // Align to page boundary to prevent drift (ensures variant 1, 6, 11, etc. in leftmost position)
          sliderState.index = alignToPageBoundary(sliderState.index, maxIndex, sliderState.visible);
          
          // Save slider position for this item so it persists across re-renders
          // This ensures the position is preserved when renderGallery() is called
          gallerySliderPositions[uniqueKey] = sliderState.index;
          
          // Calculate offset - always aligns to card boundaries (leftmost card fully visible)
          // Use spacePerCard to ensure proper alignment including margins
          const offset = -spacePerCard * sliderState.index;
          
          // Check if this is the initial render (track has no transform yet)
          const isInitialRender = !track.style.transform || track.style.transform === 'none' || track.style.transform === '';
          
          if (isInitialRender && sliderState.index > 0) {
            // On initial render with saved position, disable transition to prevent animation
            track.style.transition = 'none';
            track.style.transform = `translateX(${offset}px)`;
            // Force reflow to ensure transform is applied
            track.offsetHeight;
            // Re-enable transition for future user interactions
            track.style.transition = '';
          } else {
            // Normal update - use transition for smooth scrolling
            track.style.transform = `translateX(${offset}px)`;
          }
          
          // Smart arrow visibility logic - use actual rendered dimensions for accuracy
          const trackWidth = track.scrollWidth; // Total width of all cards including gaps
          const viewportClientWidth = viewport.clientWidth; // Visible width
          const needsScrolling = trackWidth > viewportClientWidth;
          const isAtStart = sliderState.index === 0;
          
          // At end: when scrolling further right would show empty space or we're at the last card
          // Check if the right edge of the viewport has reached or passed the right edge of the track
          const currentOffset = -(sliderState.cardWidth + gap) * sliderState.index;
          const maxOffset = viewportClientWidth - trackWidth; // Negative value when track is wider than viewport
          const isAtEnd = !needsScrolling || currentOffset <= maxOffset || sliderState.index >= maxIndex;
          
          // Left arrow: hidden at start, visible when scrolled right
          if (isAtStart || !needsScrolling) {
            prevBtn.style.display = 'none';
          } else {
            prevBtn.style.display = 'flex';
          }
          
          // Right arrow: hidden if all images fit, or if at end
          if (!needsScrolling || isAtEnd) {
            nextBtn.style.display = 'none';
          } else {
            nextBtn.style.display = 'flex';
          }
          
          // Update disabled state for accessibility
          // Only disable when truly at boundaries (prev at start, next at end)
          prevBtn.disabled = isAtStart && needsScrolling;
          nextBtn.disabled = isAtEnd && needsScrolling;
          
          // Update page indicator (page X of Y)
          // Calculate current page based on which variant is leftmost visible
          // sliderState.index is the 0-based index of the leftmost visible variant
          // Calculate total pages first
          const totalPages = needsScrolling ? Math.ceil(item.variants.length / sliderState.visible) : 1;
          
          // Calculate current page: index 0 = page 1, index 5 = page 2, etc.
          // But if we're at or past maxIndex, we're on the last page
          // Note: maxIndex is already calculated above, so we reuse it
          let currentPage;
          if (sliderState.index >= maxIndex) {
            // We're at the last page (showing the last set of variants)
            currentPage = totalPages;
          } else {
            // Normal calculation: floor(index / visible) + 1
            currentPage = Math.floor(sliderState.index / sliderState.visible) + 1;
          }
          
          // Clamp currentPage to valid range (safety check)
          const clampedCurrentPage = Math.min(Math.max(1, currentPage), totalPages);
          
          const pageIndicator = group.querySelector('.gallery-page-indicator');
          if (pageIndicator) {
            pageIndicator.textContent = `Page ${clampedCurrentPage} of ${totalPages}`;
          }
        };

        prevBtn.addEventListener('click', () => {
          // Go back by number of fully visible cards, ensuring leftmost card is always fully visible
          // Recalculate visible count to ensure it's current (in case item.variants.length changed)
          const gap = 8; // Match slider-track gap (0.5rem = 8px)
          const spacePerCard = sliderState.cardWidth + gap;
          const viewportWidth = viewport.getBoundingClientRect().width;
          const visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
          sliderState.visible = visible; // Update visible count
          
          // Calculate maxIndex (last page boundary) for alignment
          const lastPageBoundary = Math.floor((item.variants.length - 1) / visible) * visible;
          const maxIdx = Math.max(0, lastPageBoundary);
          
          // Go back by one page (visible cards), then align to page boundary
          let newIndex = Math.max(0, sliderState.index - visible);
          
          // Align to page boundary to ensure we're at variant 1, 6, 11, etc.
          // Round down to the nearest multiple of visible, then clamp to maxIdx
          newIndex = Math.floor(newIndex / visible) * visible;
          newIndex = Math.min(newIndex, maxIdx);
          
          // Ensure we don't go below 0
          sliderState.index = Math.max(0, newIndex);
          updateSlider();
        });
        nextBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          // Advance by number of fully visible cards, ensuring leftmost card is always fully visible
          // Use the same calculation as updateSlider() for consistency
          const gap = 8; // Match slider-track gap (0.5rem = 8px)
          const spacePerCard = sliderState.cardWidth + gap;
          const viewportWidth = viewport.getBoundingClientRect().width;
          const visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
          sliderState.visible = visible; // Update visible count
          
          // Calculate maxIndex (last page boundary) for alignment - MUST match updateSlider() logic
          const lastPageBoundary = Math.floor((item.variants.length - 1) / visible) * visible;
          const maxIdx = Math.max(0, lastPageBoundary);
          
          // Advance by one page (visible cards), then align to page boundary
          let newIndex = sliderState.index + visible;
          
          // Align to page boundary to ensure we're at variant 1, 6, 11, etc.
          // Round down to the nearest multiple of visible, then clamp to maxIdx
          newIndex = Math.floor(newIndex / visible) * visible;
          newIndex = Math.min(newIndex, maxIdx);
          
          // Only update if we actually moved (prevents getting stuck)
          if (newIndex > sliderState.index) {
            sliderState.index = newIndex;
            updateSlider();
          }
          updateSlider();
        });
        window.addEventListener('resize', updateSlider);
        // Initial calculation - use requestAnimationFrame to ensure DOM is fully rendered
        requestAnimationFrame(() => {
          updateSlider();
          // Double-check after a brief delay to catch any late-rendering issues
          setTimeout(updateSlider, 100);
        });

        group.appendChild(sliderWrapper);
        grid.appendChild(group);
      });

      updateGalleryWarnings();
      updateGalleryToolbar();
      updateGallerySummary();
    }

    function updateGalleryToolbar() {
      const saveBtn = document.getElementById('gallerySaveBtn');
      // Get all items with variants (items that need selection or skip)
      const itemsWithVariants = galleryItems.filter(item => item.variants.length > 0);
      
      // If no items with variants, disable button (nothing to download)
      if (itemsWithVariants.length === 0) {
        saveBtn.disabled = true;
        document.getElementById('gallerySelectFirstBtn').disabled = galleryItems.length === 0 || galleryLoading;
        document.getElementById('galleryRefreshBtn').disabled = galleryLoading;
        return;
      }
      
      // Check if all items with variants are skipped (nothing to download)
      const allSkipped = itemsWithVariants.every((item, idx) => {
        // Find original index in galleryItems
        const originalIndex = galleryItems.findIndex(gi => gi === item);
        if (originalIndex === -1) return false;
        const uniqueKey = getUniqueKey(originalIndex, item.itemId);
        return gallerySkippedItems.has(uniqueKey);
      });
      
      if (allSkipped) {
        saveBtn.disabled = true;
        document.getElementById('gallerySelectFirstBtn').disabled = galleryItems.length === 0 || galleryLoading;
        document.getElementById('galleryRefreshBtn').disabled = galleryLoading;
        return;
      }
      
      // Check all items: each must either be skipped OR have a selection
      const incompleteItems = galleryItems.filter((item, itemIndex) => {
        // Items with no variants don't need selection
        if (item.variants.length === 0) return false;
        
        const uniqueKey = getUniqueKey(itemIndex, item.itemId);
        const isSkipped = gallerySkippedItems.has(uniqueKey);
        const hasSelection = !!gallerySelections[uniqueKey];
        
        // Item is incomplete if it's not skipped AND has no selection
        return !isSkipped && !hasSelection;
      });
      
      saveBtn.disabled = incompleteItems.length > 0 || galleryLoading;
      document.getElementById('gallerySelectFirstBtn').disabled = galleryItems.length === 0 || galleryLoading;
      document.getElementById('galleryRefreshBtn').disabled = galleryLoading;
    }

    function updateGallerySummary() {
      const summaryEl = document.getElementById('gallerySelectionSummary');
      if (!summaryEl) return;
      // Count only non-skipped items (use unique keys)
      const total = galleryItems.filter((item, itemIndex) => {
        const uniqueKey = getUniqueKey(itemIndex, item.itemId);
        return !gallerySkippedItems.has(uniqueKey);
      }).length;
      // Check if selection's unique key is not in skipped items
      const selected = Object.keys(gallerySelections).filter(uniqueKey => {
        return !gallerySkippedItems.has(uniqueKey);
      }).length;
      summaryEl.textContent = `${selected} of ${total} items selected`;
    }

    function getItemDisplayLabel(itemId) {
      const item = galleryItems.find(entry => entry.itemId === itemId);
      if (item) {
        return item.productName || item.itemId;
      }
      return itemId;
    }

    function updateGalleryWarnings() {
      const warningsContainer = document.getElementById('galleryWarnings');
      const instructionEl = document.getElementById('galleryInstructionMessage');
      const groupsWithoutImages = galleryItems
        .filter(item => item.variants.length === 0)
        .map(item => getItemDisplayLabel(item.itemId));
      const groupsMissingSelections = galleryItems
        .filter((item, itemIndex) => {
          const uniqueKey = getUniqueKey(itemIndex, item.itemId);
          return item.variants.length > 0 && 
                 !gallerySkippedItems.has(uniqueKey) && 
                 !gallerySelections[uniqueKey];
        })
        .map(item => getItemDisplayLabel(item.itemId));

      if (instructionEl) {
        if (groupsMissingSelections.length > 0) {
          instructionEl.textContent = `Select one image per item (${groupsMissingSelections.length} remaining).`;
        } else if (galleryItems.length) {
          instructionEl.textContent = 'Select one image per item, then click Download Selected Items.';
      } else {
          instructionEl.textContent = '';
        }
      }

      const summarizeList = (arr, limit = 12) => {
        if (arr.length <= limit) return arr.join(', ');
        const remaining = arr.length - limit;
        return `${arr.slice(0, limit).join(', ')}, ‚Ä¶ (+${remaining})`;
      };

      let warningsHtml = '';
      if (groupsWithoutImages.length > 0) {
        warningsHtml += `<div class="gallery-warning hidden-warning">Warning: No images returned for ${summarizeList(groupsWithoutImages)}</div>`;
      }
      if (groupsMissingSelections.length > 0) {
        warningsHtml += `<div class="gallery-warning hidden-warning">Missing selections for: ${summarizeList(groupsMissingSelections)}</div>`;
      }
      if (galleryMissingItems.length > 0) {
        const detailList = galleryMissingItems.map(m => {
          const label = getItemDisplayLabel(m.itemId);
          return `${label}${m.reason ? ` (${m.reason})` : ''}`;
        });
        warningsHtml += `<div class="gallery-warning hidden-warning">Gallery API could not find images for: ${summarizeList(detailList)}</div>`;
      }
      warningsContainer.innerHTML = warningsHtml;
      const saveBtn = document.getElementById('gallerySaveBtn');
      if (saveBtn) {
        const tooltipText = warningsHtml ? warningsContainer.textContent.trim() : '';
        saveBtn.title = tooltipText || '';
      }
    }

    // Helper function to create unique key from item index and itemId
    function getUniqueKey(itemIndex, itemId) {
      return `${itemIndex}_${itemId}`;
    }
    
    // Helper function to get itemId from uniqueKey
    // uniqueKey format: "itemIndex_itemId" (e.g., "0_ItemId" or "1_Item_Id")
    function getItemIdFromUniqueKey(uniqueKey) {
      const firstUnderscoreIndex = uniqueKey.indexOf('_');
      if (firstUnderscoreIndex === -1) return uniqueKey; // Fallback if no underscore
      return uniqueKey.substring(firstUnderscoreIndex + 1); // Return everything after first underscore
    }

    function toggleGallerySelection(uniqueKey, fileName, originalItemId) {
      // uniqueKey is in format: "itemIndex_itemId" to prevent collisions when items share same itemId
      const wasSelected = gallerySelections[uniqueKey] === fileName;
      
      if (wasSelected) {
        delete gallerySelections[uniqueKey];
      } else {
        gallerySelections[uniqueKey] = fileName;
        // If item was skipped, uncheck the skip checkbox (use uniqueKey)
        if (gallerySkippedItems.has(uniqueKey)) {
          gallerySkippedItems.delete(uniqueKey);
          // Need to update the skip checkbox - find the row and update it
          updateGalleryRow(uniqueKey);
        }
      }
      
      // Optimize: Update only the affected row instead of re-rendering entire gallery
      updateGalleryRow(uniqueKey);
      updateGallerySummary();
      updateGalleryToolbar();
    }
    
    // Optimized function to update only a specific row instead of re-rendering entire gallery
    function updateGalleryRow(uniqueKey) {
      // Parse uniqueKey to get itemIndex
      const parts = uniqueKey.split('_');
      const itemIndex = parseInt(parts[0], 10);
      if (isNaN(itemIndex) || itemIndex < 0 || itemIndex >= galleryItems.length) {
        // Fallback to full render if we can't parse the key
        renderGallery();
        return;
      }
      
      const item = galleryItems[itemIndex];
      const grid = document.getElementById('galleryGrid');
      const groups = grid.querySelectorAll('.gallery-group');
      if (itemIndex >= groups.length) {
        // Fallback to full render if row doesn't exist
        renderGallery();
        return;
      }
      
      const group = groups[itemIndex];
      const track = group.querySelector('.slider-track');
      if (!track) {
        // Fallback to full render if track doesn't exist
        renderGallery();
        return;
      }
      
      // Update all cards in this row to reflect current selection state
      const cards = track.querySelectorAll('.gallery-card');
      cards.forEach((card, idx) => {
        if (idx >= item.variants.length) return;
        
        const variant = item.variants[idx];
        const currentFileName = variant.fileName;
        const isSelected = gallerySelections[uniqueKey] === currentFileName;
        
        // Update selected class
        if (isSelected) {
          card.classList.add('selected');
        } else {
          card.classList.remove('selected');
        }
      });
      
      // Update skip checkbox if needed
      const skipCheckbox = group.querySelector('.skip-checkbox');
      if (skipCheckbox) {
        const isSkipped = gallerySkippedItems.has(uniqueKey);
        skipCheckbox.checked = isSkipped;
      }
      
      // Update skipped class on group element (controls shading and strikethrough)
      const isSkipped = gallerySkippedItems.has(uniqueKey);
      if (isSkipped) {
        group.classList.add('skipped');
      } else {
        group.classList.remove('skipped');
      }
      
      // Update image count display in header
      const h5 = group.querySelector('.gallery-group-header h5');
      if (h5) {
        const countSpan = h5.querySelector('span');
        if (countSpan) {
          countSpan.textContent = `(${item.variants.length})`;
        } else {
          // If span doesn't exist, add it (shouldn't happen, but handle gracefully)
          const displayTitle = item.productName || item.itemId;
          const newCountSpan = document.createElement('span');
          newCountSpan.style.color = '#9aa4d3';
          newCountSpan.style.marginLeft = '0.5rem';
          newCountSpan.style.fontSize = '0.9em';
          newCountSpan.textContent = `(${item.variants.length})`;
          h5.textContent = displayTitle;
          h5.appendChild(newCountSpan);
        }
      }
    }

    function selectFirstVariants() {
      galleryItems.forEach((item, itemIndex) => {
        // Skip items that are marked as skipped (use unique keys)
        const uniqueKey = getUniqueKey(itemIndex, item.itemId);
        if (gallerySkippedItems.has(uniqueKey)) return;
        
        if (item.variants.length > 0) {
          gallerySelections[uniqueKey] = item.variants[0].fileName;
        }
      });
      renderGallery();
    }

    function openVariantCarousel(group, startIndex) {
      carouselGroup = group;
      carouselIndex = startIndex;
      updateCarouselView();
      document.getElementById('carouselModal').classList.add('show');
    }

    function closeVariantCarousel() {
      document.getElementById('carouselModal').classList.remove('show');
      carouselGroup = null;
      carouselIndex = 0;
    }

    function updateCarouselView() {
      if (!carouselGroup) return;
      const variant = carouselGroup.variants[carouselIndex];
      if (!variant) return;
      document.getElementById('carouselTitle').textContent = carouselGroup.productName || carouselGroup.itemId;
      const imgEl = document.getElementById('carouselImage');
      imgEl.src = variant.originalUrl || variant.previewUrl;
      imgEl.alt = variant.fileName;
      document.getElementById('carouselVariantLabel').textContent = `Variant ${carouselIndex + 1} ‚Ä¢ Source: ${variant.source || 'Unknown'}`;
      const originalLink = document.getElementById('carouselOpenOriginal');
      originalLink.href = variant.originalUrl;
    }

    function shiftCarousel(delta) {
      if (!carouselGroup) return;
      const total = carouselGroup.variants.length;
      if (total === 0) return;
      carouselIndex = (carouselIndex + delta + total) % total;
      updateCarouselView();
    }

    function useCarouselImage() {
      if (!carouselGroup) return;
      const variant = carouselGroup.variants[carouselIndex];
      if (!variant) return;
      // Find the itemIndex for carouselGroup to create unique key
      const itemIndex = galleryItems.findIndex(item => item.itemId === carouselGroup.itemId && item === carouselGroup);
      let uniqueKey;
      if (itemIndex === -1) {
        // Fallback: search by itemId (might have duplicates, use first match)
        const foundIndex = galleryItems.findIndex(item => item.itemId === carouselGroup.itemId);
        if (foundIndex === -1) {
          // Can't find the item, just close and return
          closeVariantCarousel();
          return;
        }
        uniqueKey = getUniqueKey(foundIndex, carouselGroup.itemId);
        gallerySelections[uniqueKey] = variant.fileName;
      } else {
        uniqueKey = getUniqueKey(itemIndex, carouselGroup.itemId);
        gallerySelections[uniqueKey] = variant.fileName;
      }
      
      // Calculate which page contains the selected variant and scroll to it
      // Estimate visible count (will be recalculated accurately after render)
      const estimatedVisible = 5;
      const variantIndex = carouselIndex; // 0-based index of the selected variant
      
      // Calculate target page index: align variant index to page boundary
      // Example: variant 7 (index 6) with 5 visible -> page index = floor(6/5)*5 = 5 (shows variants 6-10)
      let targetIndex = Math.floor(variantIndex / estimatedVisible) * estimatedVisible;
      
      // Calculate maxIndex (last page boundary) for clamping
      const lastPageBoundary = Math.floor((carouselGroup.variants.length - 1) / estimatedVisible) * estimatedVisible;
      const maxIdx = Math.max(0, lastPageBoundary);
      targetIndex = Math.min(targetIndex, maxIdx);
      
      // Save slider position BEFORE renderGallery() so the row scrolls to the correct page
      gallerySliderPositions[uniqueKey] = targetIndex;
      
      // Save values before closing carousel (carouselGroup will be nulled)
      const savedItemIndex = itemIndex !== -1 ? itemIndex : galleryItems.findIndex(item => item.itemId === carouselGroup.itemId);
      const savedVariantIndex = carouselIndex;
      const savedVariantsLength = carouselGroup.variants.length;
      
      renderGallery();
      closeVariantCarousel();
      
      // Fine-tune scroll position after render with accurate measurements
      // Use requestAnimationFrame to ensure DOM is fully rendered
      requestAnimationFrame(() => {
        setTimeout(() => {
          const item = galleryItems[savedItemIndex];
          if (!item) return;
          
          const group = document.querySelector(`.gallery-group[data-item-index="${savedItemIndex}"]`);
          if (!group) return;
          
          const viewport = group.querySelector('.variant-slider');
          const track = group.querySelector('.slider-track');
          if (!viewport || !track) return;
          
          // Recalculate with accurate measurements
          const gap = 8; // Match slider-track gap (0.5rem = 8px)
          const firstCard = track.querySelector('.gallery-card');
          if (!firstCard) return;
          const cardWidth = firstCard.getBoundingClientRect().width;
          const spacePerCard = cardWidth + gap;
          const viewportWidth = viewport.getBoundingClientRect().width;
          const visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
          
          // Recalculate target index with accurate visible count
          const accurateTargetIndex = Math.floor(savedVariantIndex / visible) * visible;
          const accurateLastPageBoundary = Math.floor((item.variants.length - 1) / visible) * visible;
          const accurateMaxIdx = Math.max(0, accurateLastPageBoundary);
          const finalIndex = Math.min(accurateTargetIndex, accurateMaxIdx);
          
          // Update saved position
          gallerySliderPositions[uniqueKey] = finalIndex;
          
          // Update the slider state and apply transform
          const sliderState = group._sliderState;
          if (sliderState) {
            sliderState.index = finalIndex;
            sliderState.visible = visible;
            sliderState.cardWidth = cardWidth;
            
            const offset = -spacePerCard * finalIndex;
            track.style.transform = `translateX(${offset}px)`;
            
            // Update arrows and page indicator
            const updateSlider = group._updateSlider;
            if (updateSlider) updateSlider();
          }
        }, 100);
      });
    }

    function setGalleryStatus(message) {
      document.getElementById('galleryFooterStatus').textContent = message || '';
    }

    async function refreshGallery() {
      if (!lastGalleryPayload) return;
      galleryLoading = true;
      updateGalleryToolbar();
      setGalleryStatus('Refreshing gallery...');
      const result = await apiCall('gallery_generate', lastGalleryPayload);
      galleryLoading = false;
      if (result.success) {
        galleryItems = result.items || [];
        gallerySelections = {};
        gallerySkippedItems.clear(); // Clear skipped items when refreshing
        galleryNewImages.clear(); // Clear new images tracking when refreshing
        galleryMissingItems = result.missingItems || [];
        renderGallery();
        setGalleryStatus('Gallery refreshed');
      } else {
        setGalleryStatus(`Error refreshing gallery: ${result.error || 'Unknown error'}`);
        updateGalleryToolbar();
      }
    }

    async function handleRefreshImages(itemId, refreshBtn) {
      if (!lastGalleryPayload) {
        setGalleryStatus('Error: No previous gallery data available');
        return;
      }

      const item = galleryItems.find(i => i.itemId === itemId);
      if (!item) {
        setGalleryStatus(`Error: Item ${itemId} not found`);
        return;
      }

      // Get existing image URLs to avoid duplicates (not file names, as they're regenerated each call)
      const existingUrls = new Set(item.variants.map(v => v.originalUrl));

      refreshBtn.classList.add('loading');
      refreshBtn.disabled = true;
      setGalleryStatus(`Fetching new images for ${getItemDisplayLabel(itemId)}...`);

      try {
        // Create payload for single item with 3 images
        // Use productName (the original search term) instead of itemId
        const productName = item.productName || item.itemId;
        
        // Find the index of this item in the original products array to get the correct reference item number
        const originalProducts = lastGalleryPayload.products || [];
        const itemIndex = originalProducts.findIndex(p => {
          // Try to match by productName or itemId
          return p === productName || p === item.itemId;
        });
        
        // Get the correct reference item number for this item
        const referenceItemNumbers = lastGalleryPayload.item_numbers || [];
        const itemNumber = itemIndex >= 0 && itemIndex < referenceItemNumbers.length 
          ? referenceItemNumbers[itemIndex] 
          : (item.referenceId || null);
        
        // Request more images starting from where we left off to avoid duplicates
        // If we have 33 images, request starting from position 34
        const existingCount = item.variants.length;
        const startIndex = existingCount + 1; // Start from next position (1-based)
        
        const singleItemPayload = {
          ...lastGalleryPayload,
          products: [productName], // Use the original product name/search term
          item_numbers: itemNumber ? [itemNumber] : [], // Pass the correct reference item number
          images_per_item: 10, // Request 10 images to filter for 3 unique ones
          start_index: startIndex // Pagination: start from next position to get NEW images
        };

        // TODO: Remove console.log statements in future cleanup
        console.log('Refresh Images - Payload:', {
          productName,
          itemId,
          itemNumber,
          existingImageCount: item.variants.length,
          existingUrls: Array.from(existingUrls).slice(0, 3) // Log first 3 URLs for debugging
        });

        const result = await apiCall('gallery_generate', singleItemPayload);

        if (!result.success) {
          setGalleryStatus(`Error fetching new images: ${result.error || 'Unknown error'}`);
          // TODO: Remove console.log statements in future cleanup
          console.error('Refresh Images - API Error:', result.error);
          return;
        }

        const newItems = result.items || [];
        // TODO: Remove console.log statements in future cleanup
        console.log('Refresh Images - API Response:', {
          itemsCount: newItems.length,
          firstItemId: newItems[0]?.itemId,
          expectedItemId: itemId,
          variantsCount: newItems[0]?.variants?.length || 0
        });
        
        if (newItems.length === 0) {
          setGalleryStatus(`No new images found for ${getItemDisplayLabel(itemId)}`);
          return;
        }
        
        // Check if itemId matches (allowing for referenceId matching)
        const returnedItem = newItems[0];
        const itemIdMatches = returnedItem.itemId === itemId || 
                             returnedItem.itemId === item.referenceId ||
                             (item.referenceId && returnedItem.itemId === item.referenceId);
        
        if (!itemIdMatches) {
          // TODO: Remove console.log statements in future cleanup
          console.warn('Refresh Images - ItemId mismatch:', {
            returned: returnedItem.itemId,
            expected: itemId,
            referenceId: item.referenceId
          });
          // Still try to use it if it's the only item returned
          if (newItems.length > 1) {
            setGalleryStatus(`Item mismatch for ${getItemDisplayLabel(itemId)}`);
            return;
          }
        }

        const newVariants = returnedItem.variants || [];
        // TODO: Remove console.log statements in future cleanup
        console.log('Refresh Images - New Variants:', {
          total: newVariants.length,
          urls: newVariants.map(v => v.originalUrl).slice(0, 3)
        });
        
        // Filter out duplicates by comparing image URLs (not file names, which are regenerated)
        const uniqueNewVariants = newVariants.filter(v => !existingUrls.has(v.originalUrl));
        
        // TODO: Remove console.log statements in future cleanup
        console.log('Refresh Images - After Duplicate Filter:', {
          unique: uniqueNewVariants.length,
          filtered: newVariants.length - uniqueNewVariants.length
        });

        if (uniqueNewVariants.length === 0) {
          setGalleryStatus(`No new unique images found for ${getItemDisplayLabel(itemId)} (all ${newVariants.length} were duplicates)`);
          return;
        }

        // Append new variants to existing ones (limit to 3 as requested)
        const variantsToAdd = uniqueNewVariants.slice(0, 3);
        const firstNewImageIndex = item.variants.length; // Index of first new image (0-based)
        item.variants.push(...variantsToAdd);

        // Track new images for badge display
        if (!galleryNewImages.has(itemId)) {
          galleryNewImages.set(itemId, new Set());
        }
        variantsToAdd.forEach(v => {
          galleryNewImages.get(itemId).add(v.originalUrl);
        });

        // Calculate target index BEFORE renderGallery() so the new slider is created with correct position
        // Estimate visible count (will be recalculated after render, but this gives us a starting point)
        // Use a reasonable estimate: typically 5-6 cards fit, but we'll use 5 as a safe estimate
        const estimatedVisible = 5;
        const targetIndex = firstNewImageIndex;
        
        // Calculate maxIndex (last page boundary) for alignment
        const lastPageBoundary = Math.floor((item.variants.length - 1) / estimatedVisible) * estimatedVisible;
        const maxIdx = Math.max(0, lastPageBoundary);
        
        // Align target index to page boundary (multiple of visible) to ensure proper page alignment
        // This ensures we show variant 1, 6, 11, etc. in the leftmost position
        let finalIndex = targetIndex;
        // Align to the nearest page boundary (round down to ensure we don't overshoot)
        finalIndex = Math.floor(finalIndex / estimatedVisible) * estimatedVisible;
        // Clamp to maxIdx (which is already a page boundary)
        finalIndex = Math.min(finalIndex, maxIdx);
        
        // Update saved position BEFORE renderGallery() so the new slider uses the correct position
        const targetItemIndex = galleryItems.findIndex(i => i.itemId === itemId);
        const uniqueKey = getUniqueKey(targetItemIndex, itemId);
        gallerySliderPositions[uniqueKey] = finalIndex;
        
        setGalleryStatus(`Added ${variantsToAdd.length} new image(s) for ${getItemDisplayLabel(itemId)}${uniqueNewVariants.length > 3 ? ` (${uniqueNewVariants.length - 3} more available)` : ''}`);
        renderGallery();
        
        // After render, fine-tune the position with accurate measurements
        // Use requestAnimationFrame + setTimeout to ensure DOM is fully rendered and slider is initialized
        requestAnimationFrame(() => {
          setTimeout(() => {
            const grid = document.getElementById('galleryGrid');
            const groups = grid.querySelectorAll('.gallery-group');
            
            if (targetItemIndex >= 0 && targetItemIndex < groups.length) {
              const group = groups[targetItemIndex];
              const track = group.querySelector('.slider-track');
              const viewport = group.querySelector('.slider-viewport');
              
              if (track && viewport) {
                const card = track.querySelector('.gallery-card');
                if (card) {
                  const cardRect = card.getBoundingClientRect();
                  const cardStyle = window.getComputedStyle(card);
                  const marginLeft = parseFloat(cardStyle.marginLeft) || 0;
                  const marginRight = parseFloat(cardStyle.marginRight) || 0;
                  const cardWidth = cardRect.width + marginLeft + marginRight;
                  const gap = 8; // Match slider-track gap
                  const spacePerCard = cardWidth + gap;
                  const viewportWidth = viewport.getBoundingClientRect().width;
                  const visible = Math.max(1, Math.floor(viewportWidth / spacePerCard));
                  
                  // Recalculate with accurate measurements
                  // Calculate maxIndex (last page boundary) for alignment
                  const lastPageBoundary = Math.floor((item.variants.length - 1) / visible) * visible;
                  const accurateMaxIndex = Math.max(0, lastPageBoundary);
                  
                  // Align to page boundary with accurate visible count
                  let accurateFinalIndex = targetIndex;
                  // Align to the nearest page boundary (round down to ensure we don't overshoot)
                  accurateFinalIndex = Math.floor(accurateFinalIndex / visible) * visible;
                  // Clamp to maxIndex (which is already a page boundary)
                  accurateFinalIndex = Math.min(accurateFinalIndex, accurateMaxIndex);
                  
                  // Update saved position with accurate calculation
                  gallerySliderPositions[uniqueKey] = accurateFinalIndex;
                  
                  // Manually set the transform to ensure it's applied immediately (no animation)
                  const offset = -spacePerCard * accurateFinalIndex;
                  track.style.transition = 'none'; // Disable transition for instant scroll
                  track.style.transform = `translateX(${offset}px)`;
                  track.offsetHeight; // Force reflow
                  track.style.transition = ''; // Re-enable transition
                  
                  // Trigger updateSlider to sync the sliderState with the new position
                  setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                  }, 50);
                  
                  // Update arrow visibility and page indicator
                  const prevBtn = group.querySelector('.slider-nav-prev');
                  const nextBtn = group.querySelector('.slider-nav-next');
                  const trackWidth = track.scrollWidth;
                  const needsScrolling = trackWidth > viewportWidth;
                  const isAtStart = accurateFinalIndex === 0;
                  const isAtEnd = !needsScrolling || accurateFinalIndex >= accurateMaxIndex;
                  
                  if (prevBtn) {
                    prevBtn.style.display = (isAtStart || !needsScrolling) ? 'none' : 'flex';
                    prevBtn.disabled = isAtStart && needsScrolling;
                  }
                  if (nextBtn) {
                    nextBtn.style.display = (!needsScrolling || isAtEnd) ? 'none' : 'flex';
                    nextBtn.disabled = isAtEnd && needsScrolling;
                  }
                  
                  // Update page indicator after scrolling to new images
                  const currentPage = Math.floor(accurateFinalIndex / visible) + 1;
                  const totalPages = needsScrolling ? Math.ceil(item.variants.length / visible) : 1;
                  const pageIndicator = group.querySelector('.gallery-page-indicator');
                  if (pageIndicator) {
                    pageIndicator.textContent = `Page ${currentPage} of ${totalPages}`;
                  }
                }
              }
            }
          }, 100); // Small delay to ensure slider is fully initialized
        });
      } catch (error) {
        setGalleryStatus(`Error: ${error.message || 'Unknown error'}`);
      } finally {
        refreshBtn.classList.remove('loading');
        refreshBtn.disabled = false;
      }
    }

    function getGalleryRequiredItems() {
      return galleryItems
        .filter((item, itemIndex) => {
          const uniqueKey = getUniqueKey(itemIndex, item.itemId);
          return item.variants.length > 0 && !gallerySkippedItems.has(uniqueKey);
        })
        .map(item => item.itemId);
    }

    function parseCsvToArray(csvText) {
      const rows = csvText.split(/\r?\n/).filter(Boolean);
      return rows.slice(1).map(row => row.split(','));
    }

    async function finalizeGallerySelections() {
      // Check for missing selections using unique keys
      const missing = [];
      galleryItems.forEach((item, itemIndex) => {
        const uniqueKey = getUniqueKey(itemIndex, item.itemId);
        if (item.variants.length > 0 && !gallerySkippedItems.has(uniqueKey)) {
          if (!gallerySelections[uniqueKey]) {
            missing.push(item.itemId);
          }
        }
      });
      if (missing.length > 0) {
        const missingLabels = missing.map(getItemDisplayLabel);
        setGalleryStatus(`Select one image for: ${missingLabels.join(', ')}`);
        updateGalleryWarnings();
        return;
      }

      const prefix = document.getElementById('prefix').value.trim();
      galleryLoading = true;
      updateGalleryToolbar();
      setGalleryStatus('Finalizing selection...');

      try {
        const selectionsPayload = [];
        galleryItems.forEach((item, itemIndex) => {
          // Skip items that are marked as skipped (use unique keys)
          const uniqueKey = getUniqueKey(itemIndex, item.itemId);
          if (gallerySkippedItems.has(uniqueKey)) return;
          
          const selectedFile = gallerySelections[uniqueKey];
          if (!selectedFile) return;
          const variant = item.variants.find(v => v.fileName === selectedFile);
          if (variant) {
            selectionsPayload.push({
              itemId: item.itemId,
              referenceId: item.referenceId,
              productName: item.productName,
              fileName: variant.fileName,
              originalUrl: variant.originalUrl,
              shortDescription: variant.shortDescription,
              description: variant.description,
              source: variant.source
            });
          }
        });

        // Get required items (items that need selection, not skipped)
        const requiredItems = getGalleryRequiredItems();
        
        const payload = {
          selections: selectionsPayload,
          prefix,
          reference_items: referenceItems,
          required_items: requiredItems
        };

        const result = await apiCall('gallery_finalize', payload);

        if (!result.success) {
          setGalleryStatus(`Error finalizing: ${result.error || 'Unknown error'}`);
          return;
        }

        if (result.csv_content) {
          downloadBase64File(result.csv_content, result.csv_filename || 'imagedownload.csv', 'text/csv');
          const csvText = atob(result.csv_content);
          csvData = parseCsvToArray(csvText);
        }
        if (result.zip_content) {
          downloadBase64File(result.zip_content, result.zip_filename || `downloaded_items_${Date.now()}.zip`, 'application/zip');
          
          // Check if upload after download is enabled (checkboxes are synchronized, so check either one)
          const uploadAfterDownload = document.getElementById('uploadAfterDownload');
          if (uploadAfterDownload && uploadAfterDownload.checked) {
            try {
              // Trigger upload from zip
              logToConsole('Upload to Cloudinary after download enabled. Extracting zip and uploading images...', 'info');
              setGalleryStatus('Extracting zip and uploading to Cloudinary...');
              await uploadFromZipContent(result.zip_content);
            } catch (uploadError) {
              logToConsole(`Upload error: ${uploadError.message || 'Unknown error'}`, 'error');
              setGalleryStatus(`Upload failed: ${uploadError.message || 'Unknown error'}`);
              // Continue with WM update even if upload fails
            }
          }
        }

        // Check if update WM after download is enabled
        const updateWmAfterDownload = document.getElementById('updateWmAfterDownload');
        if (updateWmAfterDownload && updateWmAfterDownload.checked && csvData) {
          try {
            // Trigger WM update - force use of csvData (the just-downloaded CSV)
            logToConsole('Update WM after download enabled. Updating WM...', 'info');
            setGalleryStatus('Updating WM...');
            await handleWmUpdate(true); // Pass true to force use of csvData
          } catch (wmError) {
            logToConsole(`WM Update error: ${wmError.message || 'Unknown error'}`, 'error');
            setGalleryStatus(`WM Update failed: ${wmError.message || 'Unknown error'}`);
            // Continue to close modal even if WM update fails
          }
        }

        document.getElementById('dlStatus').textContent = `Downloaded ${selectionsPayload.length} items via gallery.`;
        setGalleryStatus('Downloads ready. Check your browser downloads folder.');
        showScriptModal(result.csv_filename, result.zip_filename);
        galleryItems = [];
        gallerySelections = {};
        gallerySkippedItems.clear(); // Clear skipped items
        galleryNewImages.clear(); // Clear new images tracking
        galleryMissingItems = [];
        closeGalleryModal();
      } catch (error) {
        logToConsole(`Error in finalizeGallerySelections: ${error.message || 'Unknown error'}`, 'error');
        setGalleryStatus(`Error: ${error.message || 'Unknown error'}`);
      } finally {
        // Always reset loading state, even if there was an error
        galleryLoading = false;
        updateGalleryToolbar();
      }
    }

    function handleCleanupClick() {
      alert('Clean Up CSV functionality will be implemented');
    }

    // Function to upload images from zip content
    async function uploadFromZipContent(base64ZipContent) {
      try {
        logToConsole('Extracting zip file...', 'info');
        
        // Convert base64 to binary
        const binaryString = atob(base64ZipContent);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        
        // Load zip with JSZip
        const zip = await JSZip.loadAsync(bytes);
        logToConsole(`Zip extracted. Found ${Object.keys(zip.files).length} files.`, 'info');
        
        // Filter for image files and convert to File objects
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
        const imageFiles = [];
        
        for (const [filename, zipEntry] of Object.entries(zip.files)) {
          if (zipEntry.dir) continue; // Skip directories
          
          const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
          if (imageExtensions.includes(ext)) {
            const blob = await zipEntry.async('blob');
            const file = new File([blob], filename, { type: blob.type });
            imageFiles.push(file);
            logToConsole(`Found image: ${filename}`, 'info');
          }
        }
        
        if (imageFiles.length === 0) {
          logToConsole('No image files found in zip.', 'error');
          setGalleryStatus('No images found in zip file.');
          return;
        }
        
        logToConsole(`Found ${imageFiles.length} image(s). Starting upload...`, 'info');
        
        // Use the shared upload function
        await uploadImageFiles(imageFiles);
        
      } catch (error) {
        console.error('‚ùå [UPLOAD] Error uploading from zip:', error);
        logToConsole(`Error uploading from zip: ${error.message}`, 'error');
        setGalleryStatus(`Upload error: ${error.message}`);
      }
    }
    
    // Shared upload function for both directory and zip uploads
    async function uploadImageFiles(imageFiles) {
      const uploadFolder = document.getElementById('upload_folder').value.trim();
      const uploadPreset = document.getElementById('upload_profile').value.trim();
      
      // Show progress bar
      const progressContainer = document.getElementById('uploadProgressContainer');
      const progressBar = document.getElementById('uploadProgressBar');
      const progressText = document.getElementById('uploadProgressText');
      const progressPercent = document.getElementById('uploadProgressPercent');
      const timeRemaining = document.getElementById('uploadTimeRemaining');
      
      if (progressContainer) progressContainer.style.display = 'block';
      if (progressBar) progressBar.style.width = '0%';
      if (progressText) progressText.textContent = `Uploading 0/${imageFiles.length} images...`;
      if (progressPercent) progressPercent.textContent = '0%';
      if (timeRemaining) timeRemaining.textContent = '';
      
      // Track upload times for time estimation
      let uploadTimes = [];
      
      try {
        // Create FormData for file upload
        const formData = new FormData();
        
        // Add folder and preset if provided
        if (uploadFolder) {
          formData.append('folder', uploadFolder);
        }
        if (uploadPreset) {
          formData.append('preset', uploadPreset);
        }
        
        // Add all image files
        imageFiles.forEach((file) => {
          formData.append('files', file);
        });
        
        // Use SSE for real-time progress
        logToConsole(`Starting upload of ${imageFiles.length} images to Cloudinary (real-time progress)...`, 'info');
        if (uploadFolder) {
          logToConsole(`Using folder: ${uploadFolder}`, 'info');
        }
        if (uploadPreset) {
          logToConsole(`Using preset: ${uploadPreset}`, 'info');
        }
        
        // Use EventSource-like approach with fetch and ReadableStream
        const response = await fetch('/api/upload_cloudinary_stream', {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) {
          throw new Error(`Upload failed: ${response.statusText}`);
        }
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let uploadedCount = 0;
        let failedCount = 0;
        let totalDuration = 0;
        const uploadedResults = [];
        const failedResults = [];
        let totalFiles = imageFiles.length;
        
        // Helper function to format file size
        function formatFileSize(bytes) {
          if (bytes < 1024) return bytes + ' B';
          if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
          return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        // Helper function to update progress
        function updateProgress(index, total, duration) {
          const percent = Math.round((index / total) * 100);
          if (progressBar) progressBar.style.width = percent + '%';
          if (progressPercent) progressPercent.textContent = percent + '%';
          if (progressText) progressText.textContent = `Uploading ${index}/${total} images...`;
          
          // Calculate estimated time remaining
          if (uploadTimes.length > 0 && index < total) {
            const avgTime = uploadTimes.reduce((a, b) => a + b, 0) / uploadTimes.length;
            const remaining = total - index;
            const estimatedSeconds = Math.round(avgTime * remaining);
            if (timeRemaining) {
              if (estimatedSeconds < 60) {
                timeRemaining.textContent = `~${estimatedSeconds}s remaining`;
              } else {
                const minutes = Math.floor(estimatedSeconds / 60);
                const seconds = estimatedSeconds % 60;
                timeRemaining.textContent = `~${minutes}m ${seconds}s remaining`;
              }
            }
          }
        }
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';
          
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));
                
                switch (data.type) {
                  case 'start':
                    totalFiles = data.total;
                    logToConsole(`Starting upload of ${data.total} images...`, 'info');
                    break;
                    
                  case 'progress':
                    console.log(`‚¨ÜÔ∏è [UPLOAD] Progress: ${data.index}/${data.total} - ${data.filename}`);
                    break;
                    
                  case 'success':
                    uploadedCount++;
                    const successDuration = data.duration || 0;
                    uploadTimes.push(successDuration);
                    totalDuration += successDuration;
                    uploadedResults.push(data);
                    
                    // Find file size from original file list
                    const file = imageFiles.find(f => f.name.includes(data.filename));
                    const fileSize = file ? formatFileSize(file.size) : '';
                    const sizeText = fileSize ? ` (${fileSize})` : '';
                    
                    logToConsole(`‚úì [${data.index}/${data.total}] ${data.filename}${sizeText} (${data.duration}s) ‚Üí ${data.cloudinary_url}`, 'success');
                    updateProgress(data.index, data.total, successDuration);
                    break;
                    
                  case 'error':
                    failedCount++;
                    const errorDuration = data.duration || 0;
                    uploadTimes.push(errorDuration);
                    totalDuration += errorDuration;
                    failedResults.push(data);
                    
                    // Find file size from original file list
                    const errorFile = imageFiles.find(f => f.name.includes(data.filename));
                    const errorFileSize = errorFile ? formatFileSize(errorFile.size) : '';
                    const errorSizeText = errorFileSize ? ` (${errorFileSize})` : '';
                    
                    logToConsole(`‚úó [${data.index}/${data.total}] ${data.filename}${errorSizeText} (${data.duration}s): ${data.error}`, 'error');
                    updateProgress(data.index, data.total, errorDuration);
                    break;
                    
                  case 'complete':
                    const finalFailedCount = data.failed || 0;
                    if (progressBar) progressBar.style.width = '100%';
                    if (progressPercent) progressPercent.textContent = '100%';
                    if (timeRemaining) timeRemaining.textContent = '';
                    logToConsole(`‚úì Upload complete: ${data.successful} successful, ${finalFailedCount} failed (Total time: ${data.total_duration}s)`, 'success');
                    setGalleryStatus(`Upload complete: ${data.successful} successful, ${finalFailedCount} failed`);
                    alert(`Upload complete!\n\nSuccessful: ${data.successful}\nFailed: ${finalFailedCount}\nTotal time: ${data.total_duration}s\n\nCheck console for details.`);
                    break;
                }
              } catch (e) {
                console.error('‚¨ÜÔ∏è [UPLOAD] Error parsing SSE data:', e, line);
              }
            }
          }
        }
        
      } catch (error) {
        logToConsole(`Upload error: ${error.message}`, 'error');
        setGalleryStatus(`Upload error: ${error.message}`);
        alert(`Upload error: ${error.message}`);
      } finally {
        // Hide progress bar
        const progressContainer = document.getElementById('uploadProgressContainer');
        if (progressContainer) progressContainer.style.display = 'none';
      }
    }

    async function handleUploadClick() {
      console.log('‚¨ÜÔ∏è [UPLOAD] ========================================');
      console.log('‚¨ÜÔ∏è [UPLOAD] handleUploadClick() called');
      console.log('‚¨ÜÔ∏è [UPLOAD] ========================================');
      
      // Get the directory picker element
      const dirInput = document.getElementById('save_dir_file');
      const uploadFolder = document.getElementById('upload_folder').value.trim();
      
      console.log('‚¨ÜÔ∏è [UPLOAD] Initial state:', {
        dirInputExists: !!dirInput,
        filesCount: dirInput && dirInput.files ? dirInput.files.length : 0,
        uploadFolder: uploadFolder
      });
      
      logToConsole('Upload to Cloudinary button clicked...', 'info');
      
      // Check if directory has been selected
      const filesCount = dirInput && dirInput.files ? dirInput.files.length : 0;
      console.log('‚¨ÜÔ∏è [UPLOAD] Checking directory selection - filesCount:', filesCount);
      
      if (!dirInput || !dirInput.files || filesCount === 0) {
        console.log('‚¨ÜÔ∏è [UPLOAD] No directory selected, prompting user');
        logToConsole('Please select a directory first by clicking "Choose Directory" button.', 'error');
        alert('Please select a directory first by clicking "Choose Directory" button.\n\nThen select your images folder and confirm the upload dialog.');
        return;
      }
      
      console.log('‚¨ÜÔ∏è [UPLOAD] Directory selected - proceeding with upload');
      
      // Use the same filtering logic as preview
      const includeSubfoldersCheckbox = document.getElementById('include_subfolders');
      const includeSubfolders = includeSubfoldersCheckbox ? includeSubfoldersCheckbox.checked : false;
      
      console.log('‚¨ÜÔ∏è [UPLOAD] Checkbox state:', {
        checkboxExists: !!includeSubfoldersCheckbox,
        checked: includeSubfolders
      });
      
      console.log('‚¨ÜÔ∏è [UPLOAD] Calling filterImageFiles with', dirInput.files.length, 'files');
      let imageFiles = [];
      try {
        imageFiles = filterImageFiles(dirInput.files, includeSubfolders);
        console.log('‚¨ÜÔ∏è [UPLOAD] filterImageFiles completed successfully');
      } catch (error) {
        console.error('‚¨ÜÔ∏è [UPLOAD] Error in filterImageFiles:', error);
        logToConsole(`Error filtering files: ${error.message}`, 'error');
        alert(`Error filtering files: ${error.message}`);
        return;
      }
      
      // Filter to only selected images
      if (window.imageSelectionState) {
        const originalCount = imageFiles.length;
        imageFiles = imageFiles.filter(file => {
          const fileKey = file.webkitRelativePath || file.name;
          return window.imageSelectionState[fileKey] !== false; // Default true if not set
        });
        console.log('‚¨ÜÔ∏è [UPLOAD] After selection filter:', {
          originalCount: originalCount,
          selectedCount: imageFiles.length
        });
      }
      
      console.log('‚¨ÜÔ∏è [UPLOAD] Filtered result:', {
        imageFilesCount: imageFiles.length,
        totalFiles: dirInput.files.length
      });
      
      if (imageFiles.length === 0) {
        console.log('‚¨ÜÔ∏è [UPLOAD] No image files to upload');
        // Check if preview is showing - if so, use that info
        const previewContainer = document.getElementById('imagePreviewContainer');
        const previewVisible = previewContainer && previewContainer.style.display !== 'none' && previewContainer.style.display !== '';
        console.log('‚¨ÜÔ∏è [UPLOAD] Preview container state:', {
          exists: !!previewContainer,
          display: previewContainer ? previewContainer.style.display : 'N/A',
          visible: previewVisible
        });
        
        if (!previewVisible) {
          alert('No image files found in selected directory. Supported formats: JPG, PNG, GIF, WebP, BMP\n\nPlease select a directory with images or check "Include subfolders" if images are in subfolders.');
        } else {
          alert('No image files match the current filter settings. Try checking "Include subfolders" if your images are in subfolders.');
        }
        return;
      }
      
      const uploadBtn = document.getElementById('upBtn');
      const uploadPreset = document.getElementById('upload_profile').value.trim();
      
      console.log('‚¨ÜÔ∏è [UPLOAD] Starting upload process:', {
        imageCount: imageFiles.length,
        uploadFolder: uploadFolder,
        uploadPreset: uploadPreset
      });
      
      // Disable button during upload
      uploadBtn.disabled = true;
      const selectedCount = imageFiles.length;
      uploadBtn.textContent = `Uploading ${selectedCount} selected images...`;
      
      // Show progress bar
      const progressContainer = document.getElementById('uploadProgressContainer');
      const progressBar = document.getElementById('uploadProgressBar');
      const progressText = document.getElementById('uploadProgressText');
      const progressPercent = document.getElementById('uploadProgressPercent');
      const timeRemaining = document.getElementById('uploadTimeRemaining');
      
      if (progressContainer) progressContainer.style.display = 'block';
      if (progressBar) progressBar.style.width = '0%';
      if (progressText) progressText.textContent = `Uploading 0/${selectedCount} images...`;
      if (progressPercent) progressPercent.textContent = '0%';
      if (timeRemaining) timeRemaining.textContent = '';
      
      // Track upload times for time estimation
      let uploadTimes = [];
      
      try {
        // Create FormData for file upload
        const formData = new FormData();
        
        // Add folder and preset if provided
        if (uploadFolder) {
          formData.append('folder', uploadFolder);
          console.log('‚¨ÜÔ∏è [UPLOAD] Added folder to FormData:', uploadFolder);
        }
        if (uploadPreset) {
          formData.append('preset', uploadPreset);
          console.log('‚¨ÜÔ∏è [UPLOAD] Added preset to FormData:', uploadPreset);
        }
        
        // Add all image files
        console.log('‚¨ÜÔ∏è [UPLOAD] Adding files to FormData...');
        imageFiles.forEach((file, index) => {
          formData.append('files', file);
          if (index < 3) {
            console.log(`‚¨ÜÔ∏è [UPLOAD] Added file ${index + 1}:`, file.name);
          }
        });
        console.log(`‚¨ÜÔ∏è [UPLOAD] Total files added to FormData: ${imageFiles.length}`);
        
        // Use SSE for real-time progress
        logToConsole(`Starting upload of ${imageFiles.length} images to Cloudinary (real-time progress)...`, 'info');
        if (uploadFolder) {
          logToConsole(`Using folder: ${uploadFolder}`, 'info');
        }
        if (uploadPreset) {
          logToConsole(`Using preset: ${uploadPreset}`, 'info');
        }
        
        // Use EventSource-like approach with fetch and ReadableStream
        // Since EventSource doesn't support POST, we'll use fetch with streaming
        const response = await fetch('/api/upload_cloudinary_stream', {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) {
          throw new Error(`Upload failed: ${response.statusText}`);
        }
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let uploadedCount = 0;
        let failedCount = 0;
        let totalDuration = 0;
        const uploadedResults = [];
        const failedResults = [];
        let totalFiles = selectedCount;
        
        // Helper function to format file size
        function formatFileSize(bytes) {
          if (bytes < 1024) return bytes + ' B';
          if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
          return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        // Helper function to update progress
        function updateProgress(index, total, duration) {
          const percent = Math.round((index / total) * 100);
          if (progressBar) progressBar.style.width = percent + '%';
          if (progressPercent) progressPercent.textContent = percent + '%';
          if (progressText) progressText.textContent = `Uploading ${index}/${total} images...`;
          
          // Calculate estimated time remaining
          if (uploadTimes.length > 0 && index < total) {
            const avgTime = uploadTimes.reduce((a, b) => a + b, 0) / uploadTimes.length;
            const remaining = total - index;
            const estimatedSeconds = Math.round(avgTime * remaining);
            if (timeRemaining) {
              if (estimatedSeconds < 60) {
                timeRemaining.textContent = `~${estimatedSeconds}s remaining`;
              } else {
                const minutes = Math.floor(estimatedSeconds / 60);
                const seconds = estimatedSeconds % 60;
                timeRemaining.textContent = `~${minutes}m ${seconds}s remaining`;
              }
            }
          }
        }
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || ''; // Keep incomplete line in buffer
          
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));
                
                switch (data.type) {
                  case 'start':
                    totalFiles = data.total;
                    logToConsole(`Starting upload of ${data.total} images...`, 'info');
                    break;
                    
                  case 'progress':
                    console.log(`‚¨ÜÔ∏è [UPLOAD] Progress: ${data.index}/${data.total} - ${data.filename}`);
                    break;
                    
                  case 'success':
                    uploadedCount++;
                    const successDuration = data.duration || 0;
                    uploadTimes.push(successDuration);
                    totalDuration += successDuration;
                    uploadedResults.push(data);
                    
                    // Find file size from original file list
                    const file = imageFiles.find(f => {
                      const fileKey = f.webkitRelativePath || f.name;
                      return fileKey.includes(data.filename);
                    });
                    const fileSize = file ? formatFileSize(file.size) : '';
                    const sizeText = fileSize ? ` (${fileSize})` : '';
                    
                    logToConsole(`‚úì [${data.index}/${data.total}] ${data.filename}${sizeText} (${data.duration}s) ‚Üí ${data.cloudinary_url}`, 'success');
                    uploadBtn.textContent = `Uploading ${data.index}/${data.total}...`;
                    updateProgress(data.index, data.total, successDuration);
                    break;
                    
                  case 'error':
                    failedCount++;
                    const errorDuration = data.duration || 0;
                    uploadTimes.push(errorDuration);
                    totalDuration += errorDuration;
                    failedResults.push(data);
                    
                    // Find file size from original file list
                    const errorFile = imageFiles.find(f => {
                      const fileKey = f.webkitRelativePath || f.name;
                      return fileKey.includes(data.filename);
                    });
                    const errorFileSize = errorFile ? formatFileSize(errorFile.size) : '';
                    const errorSizeText = errorFileSize ? ` (${errorFileSize})` : '';
                    
                    logToConsole(`‚úó [${data.index}/${data.total}] ${data.filename}${errorSizeText} (${data.duration}s): ${data.error}`, 'error');
                    uploadBtn.textContent = `Uploading ${data.index}/${data.total}...`;
                    updateProgress(data.index, data.total, errorDuration);
                    break;
                    
                  case 'complete':
                    const finalFailedCount = data.failed || 0;
                    if (progressBar) progressBar.style.width = '100%';
                    if (progressPercent) progressPercent.textContent = '100%';
                    if (timeRemaining) timeRemaining.textContent = '';
                    logToConsole(`‚úì Upload complete: ${data.successful} successful, ${finalFailedCount} failed (Total time: ${data.total_duration}s)`, 'success');
                    alert(`Upload complete!\n\nSuccessful: ${data.successful}\nFailed: ${finalFailedCount}\nTotal time: ${data.total_duration}s\n\nCheck console for details.`);
                    break;
                }
              } catch (e) {
                console.error('‚¨ÜÔ∏è [UPLOAD] Error parsing SSE data:', e, line);
              }
            }
          }
        }
        
      } catch (error) {
        logToConsole(`Upload error: ${error.message}`, 'error');
        alert(`Upload error: ${error.message}`);
      } finally {
        uploadBtn.disabled = false;
        uploadBtn.textContent = 'Upload to Cloudinary';
        // Hide progress bar
        const progressContainer = document.getElementById('uploadProgressContainer');
        if (progressContainer) progressContainer.style.display = 'none';
      }
    }

    async function handleWmUpdate(forceUseCsvData = false) {
      // Determine which CSV data to use
      // If forceUseCsvData is true (called from download process), always use csvData
      // Otherwise, prioritize loadedCsvData (manually loaded file) over csvData (downloaded CSV)
      
      console.error('=== handleWmUpdate START ===');
      console.error('forceUseCsvData:', forceUseCsvData);
      console.error('loadedCsvData:', loadedCsvData, 'type:', typeof loadedCsvData, 'isArray:', Array.isArray(loadedCsvData), 'length:', loadedCsvData?.length);
      console.error('csvData:', csvData, 'type:', typeof csvData, 'isArray:', Array.isArray(csvData), 'length:', csvData?.length);
      
      let csvDataToUse = null;
      
      if (forceUseCsvData) {
        csvDataToUse = csvData;
        console.log('Using csvData (forced from download), length:', csvDataToUse?.length);
      } else {
        // Manual call: prioritize manually loaded CSV over downloaded CSV
        // Simple direct check: is it an array with length > 0?
        console.error('DEBUG: Checking loadedCsvData...');
        console.error('DEBUG: loadedCsvData ===', loadedCsvData);
        console.error('DEBUG: Array.isArray(loadedCsvData) ===', Array.isArray(loadedCsvData));
        console.error('DEBUG: loadedCsvData?.length ===', loadedCsvData?.length);
        console.error('DEBUG: Full condition result ===', Array.isArray(loadedCsvData) && loadedCsvData.length > 0);
        
        if (Array.isArray(loadedCsvData) && loadedCsvData.length > 0) {
          console.error('DEBUG: Condition PASSED - assigning loadedCsvData');
          csvDataToUse = loadedCsvData;
          console.error('DEBUG: csvDataToUse after assignment ===', csvDataToUse);
          console.log('Using loadedCsvData, length:', csvDataToUse.length);
        } else {
          console.error('DEBUG: Condition FAILED for loadedCsvData');
          if (Array.isArray(csvData) && csvData.length > 0) {
            csvDataToUse = csvData;
            console.log('Using csvData (fallback), length:', csvDataToUse.length);
          } else {
            console.error('DEBUG: No valid CSV data found');
            console.log('No valid CSV data found');
          }
        }
      }
      
      console.error('csvDataToUse final:', csvDataToUse, 'length:', csvDataToUse?.length);
      
      if (!csvDataToUse || !Array.isArray(csvDataToUse) || csvDataToUse.length === 0) {
        console.error('ERROR: csvDataToUse is invalid:', csvDataToUse);
        console.error('ERROR: loadedCsvData at error time:', loadedCsvData);
        console.error('ERROR: csvData at error time:', csvData);
        alert('Please load a CSV file or download items first to create CSV data.');
        return;
      }

      // Get CSV input element for reference (used later for status updates)
      const csvOutInput = document.getElementById('csv_out');

      // Get ORG - check URL parameter first, then always prompt (unless from URL)
      let org = null;
      const urlParams = new URLSearchParams(window.location.search);
      const urlOrg = urlParams.get('Organization');
      
      if (urlOrg) {
        // ORG from URL - use it (should already be authenticated, no prompt)
        org = urlOrg.trim();
        if (sessionToken && sessionOrg === org) {
          // Already authenticated with this ORG, use stored token
        } else {
          // Need to authenticate
          const authResult = await apiCall('auth', { org });
          if (!authResult.success) {
            alert(`Authentication failed: ${authResult.error}`);
            return;
          }
          sessionToken = authResult.token;
          sessionOrg = org;
        }
      } else {
        // Always prompt for ORG, pre-populate with previous value if available
        org = prompt('Enter ORG for Manhattan WMS:', sessionOrg || '');
        if (!org || !org.trim()) return;
        org = org.trim();
        
        // Authenticate (always authenticate, even if ORG matches previous)
        const authResult = await apiCall('auth', { org });
        if (!authResult.success) {
          alert(`Authentication failed: ${authResult.error}`);
          return;
        }
        sessionToken = authResult.token;
        sessionOrg = org;
      }

      const wmBtn = document.getElementById('wmBtn');
      const dlStatus = document.getElementById('dlStatus');

      // Log API call with row count and first 2 item descriptions
      const rowCount = csvDataToUse.length;
      let itemDescriptions = '';
      if (rowCount > 0) {
        const firstTwo = csvDataToUse.slice(0, 2);
        const descriptions = firstTwo.map(row => {
          // CSV structure: [ItemId, ShortDescription, Description, ...]
          // Use Description (index 2) if available, fallback to ShortDescription (index 1) or ItemId (index 0)
          const desc = (row[2] && row[2].trim()) || (row[1] && row[1].trim()) || (row[0] && row[0].trim()) || 'N/A';
          return `'${desc}'`;
        });
        itemDescriptions = ` - First items: ${descriptions.join(', ')}`;
      }
      logToConsole(`Update WM: Calling API with ${rowCount} item(s)${itemDescriptions}`, 'info');

      // Show visual indicator
      wmBtn.disabled = true;
      wmBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Updating...';
      dlStatus.textContent = 'Updating WM...';

      try {
        const result = await apiCall('update_wm', {
          org,
          token: sessionToken,
          csv_data: csvDataToUse
        });

        if (result.success) {
          const summary = `Total: ${result.total}, Success: ${result.success_count}, Failed: ${result.failed_count}`;
          logToConsole(`Update WM succeeded - ${summary}`, 'success');
          alert(`WM Update Complete!\n\nTotal: ${result.total}\nSuccess: ${result.success_count}\nFailed: ${result.failed_count}`);
          dlStatus.textContent = `WM Update complete: ${result.success_count}/${result.total} successful`;
        } else {
          logToConsole(`Update WM failed: ${result.error}`, 'error');
          alert(`WM Update failed: ${result.error}`);
          dlStatus.textContent = `Error: ${result.error}`;
        }
      } catch (error) {
        logToConsole(`Update WM error: ${error.message}`, 'error');
        alert(`WM Update failed: ${error.message}`);
        dlStatus.textContent = `Error: ${error.message}`;
      } finally {
        wmBtn.disabled = false;
        wmBtn.innerHTML = 'Update WM';
      }
    }

    function registerEventHandlers() {
      const genBtn = document.getElementById('genBtn');
      if (genBtn) genBtn.addEventListener('click', handleGenerateClick);

      const dlBtn = document.getElementById('dlBtn');
      if (dlBtn) dlBtn.addEventListener('click', handleDownloadClick);

      const cleanupBtn = document.getElementById('cleanupBtn');
      if (cleanupBtn) cleanupBtn.addEventListener('click', handleCleanupClick);

      const uploadBtn = document.getElementById('upBtn');
      if (uploadBtn) {
        uploadBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          handleUploadClick();
        });
      }

      const wmBtn = document.getElementById('wmBtn');
      if (wmBtn) wmBtn.addEventListener('click', () => handleWmUpdate(false));

      const galleryCloseBtn = document.getElementById('galleryCloseBtn');
      if (galleryCloseBtn) galleryCloseBtn.addEventListener('click', closeGalleryModal);

      const selectFirstBtn = document.getElementById('gallerySelectFirstBtn');
      if (selectFirstBtn) selectFirstBtn.addEventListener('click', selectFirstVariants);

      const refreshBtn = document.getElementById('galleryRefreshBtn');
      if (refreshBtn) refreshBtn.addEventListener('click', refreshGallery);

      const saveBtn = document.getElementById('gallerySaveBtn');
      if (saveBtn) saveBtn.addEventListener('click', finalizeGallerySelections);
      
      // Sync checkboxes between main section and gallery modal
      const uploadAfterDownload = document.getElementById('uploadAfterDownload');
      const uploadAfterDownloadGallery = document.getElementById('uploadAfterDownloadGallery');
      if (uploadAfterDownload && uploadAfterDownloadGallery) {
        // Sync main checkbox to gallery checkbox
        uploadAfterDownload.addEventListener('change', (e) => {
          uploadAfterDownloadGallery.checked = e.target.checked;
        });
        // Sync gallery checkbox to main checkbox
        uploadAfterDownloadGallery.addEventListener('change', (e) => {
          uploadAfterDownload.checked = e.target.checked;
        });
      }

      // Sync Update WM checkboxes between main section and gallery modal
      const updateWmAfterDownload = document.getElementById('updateWmAfterDownload');
      const updateWmAfterDownloadGallery = document.getElementById('updateWmAfterDownloadGallery');
      if (updateWmAfterDownload && updateWmAfterDownloadGallery) {
        // Sync main checkbox to gallery checkbox
        updateWmAfterDownload.addEventListener('change', (e) => {
          updateWmAfterDownloadGallery.checked = e.target.checked;
        });
        // Sync gallery checkbox to main checkbox
        updateWmAfterDownloadGallery.addEventListener('change', (e) => {
          updateWmAfterDownload.checked = e.target.checked;
        });
      }

      const galleryModalEl = document.getElementById('galleryModal');
      if (galleryModalEl) {
        galleryModalEl.addEventListener('click', (e) => {
          if (e.target === galleryModalEl) {
            closeGalleryModal();
          }
        });
      }

      const carouselModal = document.getElementById('carouselModal');
      const carouselCloseBtn = document.getElementById('carouselCloseBtn');
      const carouselPrevBtn = document.getElementById('carouselPrevBtn');
      const carouselNextBtn = document.getElementById('carouselNextBtn');
      const carouselUseBtn = document.getElementById('carouselUseBtn');
      if (carouselCloseBtn) carouselCloseBtn.addEventListener('click', closeVariantCarousel);
      if (carouselPrevBtn) carouselPrevBtn.addEventListener('click', () => shiftCarousel(-1));
      if (carouselNextBtn) carouselNextBtn.addEventListener('click', () => shiftCarousel(1));
      if (carouselUseBtn) carouselUseBtn.addEventListener('click', useCarouselImage);
      if (carouselModal) {
        carouselModal.addEventListener('click', (e) => {
          if (e.target === carouselModal) {
            closeVariantCarousel();
          }
        });
      }

      const scriptModal = document.getElementById('scriptModal');
      if (scriptModal) {
        scriptModal.addEventListener('click', (e) => {
          if (e.target === scriptModal) {
            closeScriptModal();
          }
        });
      }

      document.querySelectorAll('input, textarea').forEach(input => {
      input.addEventListener('change', saveConfig);
    });
    }

    window.addEventListener('DOMContentLoaded', () => {
      initUI();
      registerEventHandlers();
      apiCall('app_opened', {});
      
      // Check for ORG in URL parameter and auto-authenticate if present
      const urlParams = new URLSearchParams(window.location.search);
      const urlOrg = urlParams.get('Organization');
      if (urlOrg && urlOrg.trim()) {
        // Auto-populate ORG and authenticate silently
        sessionOrg = urlOrg.trim();
        orgFromUrl = true;
        logToConsole(`ORG detected in URL: ${sessionOrg}. Auto-authenticating...`, 'info');
        
        // Auto-authenticate in background
        apiCall('auth', { org: sessionOrg }).then(authResult => {
          if (authResult.success) {
            sessionToken = authResult.token;
            logToConsole(`Auto-authentication successful for ORG: ${sessionOrg}`, 'success');
          } else {
            logToConsole(`Auto-authentication failed for ORG: ${sessionOrg} - ${authResult.error}`, 'error');
            sessionOrg = null;
            orgFromUrl = false;
          }
        }).catch(error => {
          logToConsole(`Auto-authentication error: ${error.message}`, 'error');
          sessionOrg = null;
          orgFromUrl = false;
        });
      }
      
      logToConsole(`Item Generator ${APP_VERSION} initialized`, 'success');
      
      // Log instructions for viewing console
      console.log('%cüìä DEBUG LOGGING ENABLED', 'color: #00ff00; font-size: 16px; font-weight: bold;');
      console.log('%cTo view detailed logs:', 'color: #00ff00; font-size: 14px;');
      console.log('%c1. Press F12 (or Right-click ‚Üí Inspect)', 'color: #ffff00;');
      console.log('%c2. Click the "Console" tab', 'color: #ffff00;');
      console.log('%c3. Look for logs prefixed with: üîç [FILTER], üìã [PREVIEW], üìÅ [DIRECTORY], ‚¨ÜÔ∏è [UPLOAD], ‚òëÔ∏è [CHECKBOX]', 'color: #ffff00;');
      console.log('%cAll logs are prefixed with emojis for easy identification', 'color: #00ff00;');
    });

    function generatePowerShellScript(csvFileName, zipFileName) {
      const imageDir = document.getElementById('save_dir').value.trim();
      if (!imageDir) {
        return '# Please specify Image Directory first\n# Then re-run Download Items to generate the script';
      }
      const escapedPath = imageDir.replace(/\\/g, '\\\\').replace(/'/g, "''").replace(/"/g, '\\"');
      const downloadsPath = '$env:USERPROFILE + "\\\\Downloads"';
      const safeCsv = csvFileName || 'imagedownload.csv';
      const safeZip = zipFileName || 'downloaded_items_latest.zip';
      const script = '# PowerShell Script to Move Downloaded Files\n' +
        '# Generated by Item Generator\n\n' +
        '# Source and destination paths\n' +
        '$sourceDir = ' + downloadsPath + '\n' +
        '$destDir = "' + escapedPath + '"\n\n' +
        '$csvFileName = "' + safeCsv + '"\n' +
        '$zipFileName = "' + safeZip + '"\n\n' +
        '# Create destination directory if it doesn\'t exist\n' +
        'if (-not (Test-Path $destDir)) {\n' +
        '    New-Item -ItemType Directory -Path $destDir -Force | Out-Null\n' +
        '    Write-Host "Created directory: $destDir" -ForegroundColor Green\n' +
        '}\n\n' +
        '# Move CSV file\n' +
        '$csvFile = Join-Path $sourceDir $csvFileName\n' +
        'if (Test-Path $csvFile) {\n' +
        '    try {\n' +
        '        Move-Item -Path $csvFile -Destination $destDir -Force -ErrorAction Stop\n' +
        '        Write-Host "Moved CSV: $csvFileName" -ForegroundColor Cyan\n' +
        '    } catch {\n' +
        '        Write-Host "Error moving CSV: $_" -ForegroundColor Red\n' +
        '    }\n' +
        '} else {\n' +
        '    Write-Host "CSV file not found: $csvFileName" -ForegroundColor Yellow\n' +
        '}\n\n' +
        '# Move ZIP file and extract contents\n' +
        '$zipFile = Join-Path $sourceDir $zipFileName\n' +
        'if (Test-Path $zipFile) {\n' +
        '    try {\n' +
        '        $destZip = Join-Path $destDir $zipFileName\n' +
        '        Move-Item -Path $zipFile -Destination $destDir -Force -ErrorAction Stop\n' +
        '        Write-Host "Moved ZIP: $zipFileName" -ForegroundColor Cyan\n' +
        '        try {\n' +
        '            Expand-Archive -Path $destZip -DestinationPath $destDir -Force\n' +
        '            Write-Host "Extracted ZIP into: $destDir" -ForegroundColor Green\n' +
        '        } catch {\n' +
        '            Write-Host "Error extracting ZIP: $_" -ForegroundColor Red\n' +
        '        }\n' +
        '    } catch {\n' +
        '        Write-Host "Error moving ZIP: $_" -ForegroundColor Red\n' +
        '    }\n' +
        '} else {\n' +
        '    Write-Host "ZIP file not found: $zipFileName" -ForegroundColor Yellow\n' +
        '}\n\n' +
        'Write-Host "`nMove operation complete!" -ForegroundColor Green\n' +
        'Write-Host "Files moved/extracted to: $destDir" -ForegroundColor Green\n' +
        'Read-Host "Press Enter to exit"';
      return script;
    }

    function showScriptModal(csvFileName, zipFileName) {
      fullScriptContent = generatePowerShellScript(csvFileName, zipFileName);
      const lines = fullScriptContent.split('\n');
      const maxLines = 50;
      const truncated = lines.length > maxLines ? lines.slice(0, maxLines).join('\n') : fullScriptContent;
      const display = document.getElementById('scriptDisplay');
      display.textContent = truncated;
      if (lines.length > maxLines) {
        display.classList.add('truncated');
      } else {
        display.classList.remove('truncated');
      }
      document.getElementById('scriptModal').classList.add('show');
    }

    function closeScriptModal() {
      document.getElementById('scriptModal').classList.remove('show');
    }

    function downloadScript() {
      const blob = new Blob([fullScriptContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'move_files.ps1';
      a.click();
      URL.revokeObjectURL(url);
      logToConsole('PowerShell script downloaded', 'success');
    }

    function copyScript(evt) {
      navigator.clipboard.writeText(fullScriptContent).then(() => {
        logToConsole('PowerShell script copied to clipboard', 'success');
        const btn = evt ? evt.target : document.querySelector('#scriptModal .btn-primary');
        if (btn) {
          const originalText = btn.textContent;
          btn.textContent = 'Copied!';
          btn.classList.add('btn-success');
          btn.classList.remove('btn-primary');
          setTimeout(() => {
            btn.textContent = originalText;
            btn.classList.remove('btn-success');
            btn.classList.add('btn-primary');
          }, 2000);
        }
      }).catch(err => {
        logToConsole('Failed to copy script: ' + err.message, 'error');
        alert('Failed to copy script. Please select and copy manually.');
      });
    }

  </script>
</body>
</html>

